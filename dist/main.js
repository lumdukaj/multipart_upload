/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./node_modules/@transloadit/prettier-bytes/dist/prettierBytes.js":
/*!************************************************************************!*\
  !*** ./node_modules/@transloadit/prettier-bytes/dist/prettierBytes.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = function prettierBytes(input) {\n    if (typeof input !== 'number' || Number.isNaN(input)) {\n        throw new TypeError(`Expected a number, got ${typeof input}`);\n    }\n    const neg = input < 0;\n    let num = Math.abs(input);\n    if (neg) {\n        num = -num;\n    }\n    if (num === 0) {\n        return '0 B';\n    }\n    const units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n    const exponent = Math.min(Math.floor(Math.log(num) / Math.log(1024)), units.length - 1);\n    const value = Number(num / 1024 ** exponent);\n    const unit = units[exponent];\n    return `${value >= 10 || value % 1 === 0 ? Math.round(value) : value.toFixed(1)} ${unit}`;\n};\n//# sourceMappingURL=prettierBytes.js.map\n\n//# sourceURL=webpack://vpuploader/./node_modules/@transloadit/prettier-bytes/dist/prettierBytes.js?");

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/_Symbol.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/lodash/_Symbol.js\"),\n    getRawTag = __webpack_require__(/*! ./_getRawTag */ \"./node_modules/lodash/_getRawTag.js\"),\n    objectToString = __webpack_require__(/*! ./_objectToString */ \"./node_modules/lodash/_objectToString.js\");\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/_baseGetTag.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ \"./node_modules/lodash/_trimmedEndIndex.js\");\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/_baseTrim.js?");

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\nmodule.exports = freeGlobal;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/_freeGlobal.js?");

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/lodash/_Symbol.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/_getRawTag.js?");

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ ((module) => {

eval("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/_objectToString.js?");

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ \"./node_modules/lodash/_freeGlobal.js\");\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/_root.js?");

/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/_trimmedEndIndex.js?");

/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    now = __webpack_require__(/*! ./now */ \"./node_modules/lodash/now.js\"),\n    toNumber = __webpack_require__(/*! ./toNumber */ \"./node_modules/lodash/toNumber.js\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/debounce.js?");

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/isObject.js?");

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

eval("/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/isObjectLike.js?");

/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/lodash/_baseGetTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/isSymbol.js?");

/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/now.js?");

/***/ }),

/***/ "./node_modules/lodash/throttle.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/throttle.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var debounce = __webpack_require__(/*! ./debounce */ \"./node_modules/lodash/debounce.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/throttle.js?");

/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseTrim = __webpack_require__(/*! ./_baseTrim */ \"./node_modules/lodash/_baseTrim.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/lodash/toNumber.js?");

/***/ }),

/***/ "./node_modules/mime-match/index.js":
/*!******************************************!*\
  !*** ./node_modules/mime-match/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var wildcard = __webpack_require__(/*! wildcard */ \"./node_modules/wildcard/index.js\");\nvar reMimePartSplit = /[\\/\\+\\.]/;\n\n/**\n  # mime-match\n\n  A simple function to checker whether a target mime type matches a mime-type\n  pattern (e.g. image/jpeg matches image/jpeg OR image/*).\n\n  ## Example Usage\n\n  <<< example.js\n\n**/\nmodule.exports = function(target, pattern) {\n  function test(pattern) {\n    var result = wildcard(pattern, target, reMimePartSplit);\n\n    // ensure that we have a valid mime type (should have two parts)\n    return result && result.length >= 2;\n  }\n\n  return pattern ? test(pattern.split(';')[0]) : test;\n};\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/mime-match/index.js?");

/***/ }),

/***/ "./node_modules/namespace-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/namespace-emitter/index.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/**\n* Create an event emitter with namespaces\n* @name createNamespaceEmitter\n* @example\n* var emitter = require('./index')()\n*\n* emitter.on('*', function () {\n*   console.log('all events emitted', this.event)\n* })\n*\n* emitter.on('example', function () {\n*   console.log('example event emitted')\n* })\n*/\nmodule.exports = function createNamespaceEmitter () {\n  var emitter = {}\n  var _fns = emitter._fns = {}\n\n  /**\n  * Emit an event. Optionally namespace the event. Handlers are fired in the order in which they were added with exact matches taking precedence. Separate the namespace and event with a `:`\n  * @name emit\n  * @param {String} event – the name of the event, with optional namespace\n  * @param {...*} data – up to 6 arguments that are passed to the event listener\n  * @example\n  * emitter.emit('example')\n  * emitter.emit('demo:test')\n  * emitter.emit('data', { example: true}, 'a string', 1)\n  */\n  emitter.emit = function emit (event, arg1, arg2, arg3, arg4, arg5, arg6) {\n    var toEmit = getListeners(event)\n\n    if (toEmit.length) {\n      emitAll(event, toEmit, [arg1, arg2, arg3, arg4, arg5, arg6])\n    }\n  }\n\n  /**\n  * Create en event listener.\n  * @name on\n  * @param {String} event\n  * @param {Function} fn\n  * @example\n  * emitter.on('example', function () {})\n  * emitter.on('demo', function () {})\n  */\n  emitter.on = function on (event, fn) {\n    if (!_fns[event]) {\n      _fns[event] = []\n    }\n\n    _fns[event].push(fn)\n  }\n\n  /**\n  * Create en event listener that fires once.\n  * @name once\n  * @param {String} event\n  * @param {Function} fn\n  * @example\n  * emitter.once('example', function () {})\n  * emitter.once('demo', function () {})\n  */\n  emitter.once = function once (event, fn) {\n    function one () {\n      fn.apply(this, arguments)\n      emitter.off(event, one)\n    }\n    this.on(event, one)\n  }\n\n  /**\n  * Stop listening to an event. Stop all listeners on an event by only passing the event name. Stop a single listener by passing that event handler as a callback.\n  * You must be explicit about what will be unsubscribed: `emitter.off('demo')` will unsubscribe an `emitter.on('demo')` listener,\n  * `emitter.off('demo:example')` will unsubscribe an `emitter.on('demo:example')` listener\n  * @name off\n  * @param {String} event\n  * @param {Function} [fn] – the specific handler\n  * @example\n  * emitter.off('example')\n  * emitter.off('demo', function () {})\n  */\n  emitter.off = function off (event, fn) {\n    var keep = []\n\n    if (event && fn) {\n      var fns = this._fns[event]\n      var i = 0\n      var l = fns ? fns.length : 0\n\n      for (i; i < l; i++) {\n        if (fns[i] !== fn) {\n          keep.push(fns[i])\n        }\n      }\n    }\n\n    keep.length ? this._fns[event] = keep : delete this._fns[event]\n  }\n\n  function getListeners (e) {\n    var out = _fns[e] ? _fns[e] : []\n    var idx = e.indexOf(':')\n    var args = (idx === -1) ? [e] : [e.substring(0, idx), e.substring(idx + 1)]\n\n    var keys = Object.keys(_fns)\n    var i = 0\n    var l = keys.length\n\n    for (i; i < l; i++) {\n      var key = keys[i]\n      if (key === '*') {\n        out = out.concat(_fns[key])\n      }\n\n      if (args.length === 2 && args[0] === key) {\n        out = out.concat(_fns[key])\n        break\n      }\n    }\n\n    return out\n  }\n\n  function emitAll (e, fns, args) {\n    var i = 0\n    var l = fns.length\n\n    for (i; i < l; i++) {\n      if (!fns[i]) break\n      fns[i].event = e\n      fns[i].apply(fns[i], args)\n    }\n  }\n\n  return emitter\n}\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/namespace-emitter/index.js?");

/***/ }),

/***/ "./node_modules/retry/index.js":
/*!*************************************!*\
  !*** ./node_modules/retry/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/retry */ \"./node_modules/retry/lib/retry.js\");\n\n//# sourceURL=webpack://vpuploader/./node_modules/retry/index.js?");

/***/ }),

/***/ "./node_modules/retry/lib/retry.js":
/*!*****************************************!*\
  !*** ./node_modules/retry/lib/retry.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var RetryOperation = __webpack_require__(/*! ./retry_operation */ \"./node_modules/retry/lib/retry_operation.js\");\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/retry/lib/retry.js?");

/***/ }),

/***/ "./node_modules/retry/lib/retry_operation.js":
/*!***************************************************!*\
  !*** ./node_modules/retry/lib/retry_operation.js ***!
  \***************************************************/
/***/ ((module) => {

eval("function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/retry/lib/retry_operation.js?");

/***/ }),

/***/ "./node_modules/wildcard/index.js":
/*!****************************************!*\
  !*** ./node_modules/wildcard/index.js ***!
  \****************************************/
/***/ ((module) => {

eval("/* jshint node: true */\n\n\n/**\n  # wildcard\n\n  Very simple wildcard matching, which is designed to provide the same\n  functionality that is found in the\n  [eve](https://github.com/adobe-webplatform/eve) eventing library.\n\n  ## Usage\n\n  It works with strings:\n\n  <<< examples/strings.js\n\n  Arrays:\n\n  <<< examples/arrays.js\n\n  Objects (matching against keys):\n\n  <<< examples/objects.js\n\n  While the library works in Node, if you are are looking for file-based\n  wildcard matching then you should have a look at:\n\n  <https://github.com/isaacs/node-glob>\n**/\n\nfunction WildcardMatcher(text, separator) {\n  this.text = text = text || '';\n  this.hasWild = ~text.indexOf('*');\n  this.separator = separator;\n  this.parts = text.split(separator);\n}\n\nWildcardMatcher.prototype.match = function(input) {\n  var matches = true;\n  var parts = this.parts;\n  var ii;\n  var partsCount = parts.length;\n  var testParts;\n\n  if (typeof input == 'string' || input instanceof String) {\n    if (!this.hasWild && this.text != input) {\n      matches = false;\n    } else {\n      testParts = (input || '').split(this.separator);\n      for (ii = 0; matches && ii < partsCount; ii++) {\n        if (parts[ii] === '*')  {\n          continue;\n        } else if (ii < testParts.length) {\n          matches = parts[ii] === testParts[ii];\n        } else {\n          matches = false;\n        }\n      }\n\n      // If matches, then return the component parts\n      matches = matches && testParts;\n    }\n  }\n  else if (typeof input.splice == 'function') {\n    matches = [];\n\n    for (ii = input.length; ii--; ) {\n      if (this.match(input[ii])) {\n        matches[matches.length] = input[ii];\n      }\n    }\n  }\n  else if (typeof input == 'object') {\n    matches = {};\n\n    for (var key in input) {\n      if (this.match(key)) {\n        matches[key] = input[key];\n      }\n    }\n  }\n\n  return matches;\n};\n\nmodule.exports = function(text, test, separator) {\n  var matcher = new WildcardMatcher(text, separator || /[\\/\\.]/);\n  if (typeof test != 'undefined') {\n    return matcher.match(test);\n  }\n\n  return matcher;\n};\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/wildcard/index.js?");

/***/ }),

/***/ "./node_modules/@uppy/aws-s3/lib/HTTPCommunicationQueue.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@uppy/aws-s3/lib/HTTPCommunicationQueue.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HTTPCommunicationQueue: () => (/* binding */ HTTPCommunicationQueue)\n/* harmony export */ });\n/* harmony import */ var _MultipartUploader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MultipartUploader.js */ \"./node_modules/@uppy/aws-s3/lib/MultipartUploader.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@uppy/aws-s3/lib/utils.js\");\nfunction _classPrivateFieldLooseBase(e, t) { if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\"); return e; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(e) { return \"__private_\" + id++ + \"_\" + e; }\n\n\nfunction removeMetadataFromURL(urlString) {\n  const urlObject = new URL(urlString);\n  urlObject.search = '';\n  urlObject.hash = '';\n  return urlObject.href;\n}\nvar _abortMultipartUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"abortMultipartUpload\");\nvar _cache = /*#__PURE__*/_classPrivateFieldLooseKey(\"cache\");\nvar _createMultipartUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"createMultipartUpload\");\nvar _fetchSignature = /*#__PURE__*/_classPrivateFieldLooseKey(\"fetchSignature\");\nvar _getUploadParameters = /*#__PURE__*/_classPrivateFieldLooseKey(\"getUploadParameters\");\nvar _listParts = /*#__PURE__*/_classPrivateFieldLooseKey(\"listParts\");\nvar _previousRetryDelay = /*#__PURE__*/_classPrivateFieldLooseKey(\"previousRetryDelay\");\nvar _requests = /*#__PURE__*/_classPrivateFieldLooseKey(\"requests\");\nvar _retryDelays = /*#__PURE__*/_classPrivateFieldLooseKey(\"retryDelays\");\nvar _sendCompletionRequest = /*#__PURE__*/_classPrivateFieldLooseKey(\"sendCompletionRequest\");\nvar _setS3MultipartState = /*#__PURE__*/_classPrivateFieldLooseKey(\"setS3MultipartState\");\nvar _uploadPartBytes = /*#__PURE__*/_classPrivateFieldLooseKey(\"uploadPartBytes\");\nvar _getFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"getFile\");\nvar _shouldRetry = /*#__PURE__*/_classPrivateFieldLooseKey(\"shouldRetry\");\nvar _nonMultipartUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"nonMultipartUpload\");\nclass HTTPCommunicationQueue {\n  constructor(_requests2, options, setS3MultipartState, getFile) {\n    Object.defineProperty(this, _nonMultipartUpload, {\n      value: _nonMultipartUpload2\n    });\n    Object.defineProperty(this, _shouldRetry, {\n      value: _shouldRetry2\n    });\n    Object.defineProperty(this, _abortMultipartUpload, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _cache, {\n      writable: true,\n      value: new WeakMap()\n    });\n    Object.defineProperty(this, _createMultipartUpload, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _fetchSignature, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _getUploadParameters, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _listParts, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _previousRetryDelay, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _requests, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _retryDelays, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _sendCompletionRequest, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _setS3MultipartState, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _uploadPartBytes, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _getFile, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _requests)[_requests] = _requests2;\n    _classPrivateFieldLooseBase(this, _setS3MultipartState)[_setS3MultipartState] = setS3MultipartState;\n    _classPrivateFieldLooseBase(this, _getFile)[_getFile] = getFile;\n    this.setOptions(options);\n  }\n  setOptions(options) {\n    const requests = _classPrivateFieldLooseBase(this, _requests)[_requests];\n    if ('abortMultipartUpload' in options) {\n      _classPrivateFieldLooseBase(this, _abortMultipartUpload)[_abortMultipartUpload] = requests.wrapPromiseFunction(options.abortMultipartUpload, {\n        priority: 1\n      });\n    }\n    if ('createMultipartUpload' in options) {\n      _classPrivateFieldLooseBase(this, _createMultipartUpload)[_createMultipartUpload] = requests.wrapPromiseFunction(options.createMultipartUpload, {\n        priority: -1\n      });\n    }\n    if ('signPart' in options) {\n      _classPrivateFieldLooseBase(this, _fetchSignature)[_fetchSignature] = requests.wrapPromiseFunction(options.signPart);\n    }\n    if ('listParts' in options) {\n      _classPrivateFieldLooseBase(this, _listParts)[_listParts] = requests.wrapPromiseFunction(options.listParts);\n    }\n    if ('completeMultipartUpload' in options) {\n      _classPrivateFieldLooseBase(this, _sendCompletionRequest)[_sendCompletionRequest] = requests.wrapPromiseFunction(options.completeMultipartUpload, {\n        priority: 1\n      });\n    }\n    if ('retryDelays' in options) {\n      var _options$retryDelays;\n      _classPrivateFieldLooseBase(this, _retryDelays)[_retryDelays] = (_options$retryDelays = options.retryDelays) != null ? _options$retryDelays : [];\n    }\n    if ('uploadPartBytes' in options) {\n      _classPrivateFieldLooseBase(this, _uploadPartBytes)[_uploadPartBytes] = requests.wrapPromiseFunction(options.uploadPartBytes, {\n        priority: Infinity\n      });\n    }\n    if ('getUploadParameters' in options) {\n      _classPrivateFieldLooseBase(this, _getUploadParameters)[_getUploadParameters] = requests.wrapPromiseFunction(options.getUploadParameters);\n    }\n  }\n  async getUploadId(file, signal) {\n    let cachedResult;\n    // As the cache is updated asynchronously, there could be a race condition\n    // where we just miss a new result so we loop here until we get nothing back,\n    // at which point it's out turn to create a new cache entry.\n    // eslint-disable-next-line no-cond-assign\n    while ((cachedResult = _classPrivateFieldLooseBase(this, _cache)[_cache].get(file.data)) != null) {\n      try {\n        return await cachedResult;\n      } catch {\n        // In case of failure, we want to ignore the cached error.\n        // At this point, either there's a new cached value, or we'll exit the loop a create a new one.\n      }\n    }\n    const promise = _classPrivateFieldLooseBase(this, _createMultipartUpload)[_createMultipartUpload](_classPrivateFieldLooseBase(this, _getFile)[_getFile](file), signal);\n    const abortPromise = () => {\n      promise.abort(signal.reason);\n      _classPrivateFieldLooseBase(this, _cache)[_cache].delete(file.data);\n    };\n    signal.addEventListener('abort', abortPromise, {\n      once: true\n    });\n    _classPrivateFieldLooseBase(this, _cache)[_cache].set(file.data, promise);\n    promise.then(async result => {\n      signal.removeEventListener('abort', abortPromise);\n      _classPrivateFieldLooseBase(this, _setS3MultipartState)[_setS3MultipartState](file, result);\n      _classPrivateFieldLooseBase(this, _cache)[_cache].set(file.data, result);\n    }, () => {\n      signal.removeEventListener('abort', abortPromise);\n      _classPrivateFieldLooseBase(this, _cache)[_cache].delete(file.data);\n    });\n    return promise;\n  }\n  async abortFileUpload(file) {\n    const result = _classPrivateFieldLooseBase(this, _cache)[_cache].get(file.data);\n    if (result == null) {\n      // If the createMultipartUpload request never was made, we don't\n      // need to send the abortMultipartUpload request.\n      return;\n    }\n    // Remove the cache entry right away for follow-up requests do not try to\n    // use the soon-to-be aborted cached values.\n    _classPrivateFieldLooseBase(this, _cache)[_cache].delete(file.data);\n    _classPrivateFieldLooseBase(this, _setS3MultipartState)[_setS3MultipartState](file, Object.create(null));\n    let awaitedResult;\n    try {\n      awaitedResult = await result;\n    } catch {\n      // If the cached result rejects, there's nothing to abort.\n      return;\n    }\n    await _classPrivateFieldLooseBase(this, _abortMultipartUpload)[_abortMultipartUpload](_classPrivateFieldLooseBase(this, _getFile)[_getFile](file), awaitedResult);\n  }\n  async uploadFile(file, chunks, signal) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.throwIfAborted)(signal);\n    if (chunks.length === 1 && !chunks[0].shouldUseMultipart) {\n      return _classPrivateFieldLooseBase(this, _nonMultipartUpload)[_nonMultipartUpload](file, chunks[0], signal);\n    }\n    const {\n      uploadId,\n      key\n    } = await this.getUploadId(file, signal);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.throwIfAborted)(signal);\n    try {\n      const parts = await Promise.all(chunks.map((chunk, i) => this.uploadChunk(file, i + 1, chunk, signal)));\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.throwIfAborted)(signal);\n      return await _classPrivateFieldLooseBase(this, _sendCompletionRequest)[_sendCompletionRequest](_classPrivateFieldLooseBase(this, _getFile)[_getFile](file), {\n        key,\n        uploadId,\n        parts,\n        signal\n      }, signal).abortOn(signal);\n    } catch (err) {\n      if ((err == null ? void 0 : err.cause) !== _MultipartUploader_js__WEBPACK_IMPORTED_MODULE_0__.pausingUploadReason && (err == null ? void 0 : err.name) !== 'AbortError') {\n        // We purposefully don't wait for the promise and ignore its status,\n        // because we want the error `err` to bubble up ASAP to report it to the\n        // user. A failure to abort is not that big of a deal anyway.\n        this.abortFileUpload(file);\n      }\n      throw err;\n    }\n  }\n  restoreUploadFile(file, uploadIdAndKey) {\n    _classPrivateFieldLooseBase(this, _cache)[_cache].set(file.data, uploadIdAndKey);\n  }\n  async resumeUploadFile(file, chunks, signal) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.throwIfAborted)(signal);\n    if (chunks.length === 1 && chunks[0] != null && !chunks[0].shouldUseMultipart) {\n      return _classPrivateFieldLooseBase(this, _nonMultipartUpload)[_nonMultipartUpload](file, chunks[0], signal);\n    }\n    const {\n      uploadId,\n      key\n    } = await this.getUploadId(file, signal);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.throwIfAborted)(signal);\n    const alreadyUploadedParts = await _classPrivateFieldLooseBase(this, _listParts)[_listParts](_classPrivateFieldLooseBase(this, _getFile)[_getFile](file), {\n      uploadId,\n      key,\n      signal\n    }, signal).abortOn(signal);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.throwIfAborted)(signal);\n    const parts = await Promise.all(chunks.map((chunk, i) => {\n      const partNumber = i + 1;\n      const alreadyUploadedInfo = alreadyUploadedParts.find(_ref => {\n        let {\n          PartNumber\n        } = _ref;\n        return PartNumber === partNumber;\n      });\n      if (alreadyUploadedInfo == null) {\n        return this.uploadChunk(file, partNumber, chunk, signal);\n      }\n      // Already uploaded chunks are set to null. If we are restoring the upload, we need to mark it as already uploaded.\n      chunk == null || chunk.setAsUploaded == null || chunk.setAsUploaded();\n      return {\n        PartNumber: partNumber,\n        ETag: alreadyUploadedInfo.ETag\n      };\n    }));\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.throwIfAborted)(signal);\n    return _classPrivateFieldLooseBase(this, _sendCompletionRequest)[_sendCompletionRequest](_classPrivateFieldLooseBase(this, _getFile)[_getFile](file), {\n      key,\n      uploadId,\n      parts,\n      signal\n    }, signal).abortOn(signal);\n  }\n  async uploadChunk(file, partNumber, chunk, signal) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.throwIfAborted)(signal);\n    const {\n      uploadId,\n      key\n    } = await this.getUploadId(file, signal);\n    const signatureRetryIterator = _classPrivateFieldLooseBase(this, _retryDelays)[_retryDelays].values();\n    const chunkRetryIterator = _classPrivateFieldLooseBase(this, _retryDelays)[_retryDelays].values();\n    const shouldRetrySignature = () => {\n      const next = signatureRetryIterator.next();\n      if (next == null || next.done) {\n        return null;\n      }\n      return next.value;\n    };\n    for (;;) {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.throwIfAborted)(signal);\n      const chunkData = chunk.getData();\n      const {\n        onProgress,\n        onComplete\n      } = chunk;\n      let signature;\n      try {\n        signature = await _classPrivateFieldLooseBase(this, _fetchSignature)[_fetchSignature](_classPrivateFieldLooseBase(this, _getFile)[_getFile](file), {\n          uploadId,\n          key,\n          partNumber,\n          body: chunkData,\n          signal\n        }).abortOn(signal);\n      } catch (err) {\n        const timeout = shouldRetrySignature();\n        if (timeout == null || signal.aborted) {\n          throw err;\n        }\n        await new Promise(resolve => setTimeout(resolve, timeout));\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.throwIfAborted)(signal);\n      try {\n        return {\n          PartNumber: partNumber,\n          ...(await _classPrivateFieldLooseBase(this, _uploadPartBytes)[_uploadPartBytes]({\n            signature,\n            body: chunkData,\n            size: chunkData.size,\n            onProgress,\n            onComplete,\n            signal\n          }).abortOn(signal))\n        };\n      } catch (err) {\n        if (!(await _classPrivateFieldLooseBase(this, _shouldRetry)[_shouldRetry](err, chunkRetryIterator))) throw err;\n      }\n    }\n  }\n}\nasync function _shouldRetry2(err, retryDelayIterator) {\n  var _err$source;\n  const requests = _classPrivateFieldLooseBase(this, _requests)[_requests];\n  const status = err == null || (_err$source = err.source) == null ? void 0 : _err$source.status;\n\n  // TODO: this retry logic is taken out of Tus. We should have a centralized place for retrying,\n  // perhaps the rate limited queue, and dedupe all plugins with that.\n  if (status == null) {\n    return false;\n  }\n  if (status === 403 && err.message === 'Request has expired') {\n    if (!requests.isPaused) {\n      // We don't want to exhaust the retryDelayIterator as long as there are\n      // more than one request in parallel, to give slower connection a chance\n      // to catch up with the expiry set in Companion.\n      if (requests.limit === 1 || _classPrivateFieldLooseBase(this, _previousRetryDelay)[_previousRetryDelay] == null) {\n        const next = retryDelayIterator.next();\n        if (next == null || next.done) {\n          return false;\n        }\n        // If there are more than 1 request done in parallel, the RLQ limit is\n        // decreased and the failed request is requeued after waiting for a bit.\n        // If there is only one request in parallel, the limit can't be\n        // decreased, so we iterate over `retryDelayIterator` as we do for\n        // other failures.\n        // `#previousRetryDelay` caches the value so we can re-use it next time.\n        _classPrivateFieldLooseBase(this, _previousRetryDelay)[_previousRetryDelay] = next.value;\n      }\n      // No need to stop the other requests, we just want to lower the limit.\n      requests.rateLimit(0);\n      await new Promise(resolve => setTimeout(resolve, _classPrivateFieldLooseBase(this, _previousRetryDelay)[_previousRetryDelay]));\n    }\n  } else if (status === 429) {\n    // HTTP 429 Too Many Requests => to avoid the whole download to fail, pause all requests.\n    if (!requests.isPaused) {\n      const next = retryDelayIterator.next();\n      if (next == null || next.done) {\n        return false;\n      }\n      requests.rateLimit(next.value);\n    }\n  } else if (status > 400 && status < 500 && status !== 409) {\n    // HTTP 4xx, the server won't send anything, it's doesn't make sense to retry\n    return false;\n  } else if (typeof navigator !== 'undefined' && navigator.onLine === false) {\n    // The navigator is offline, let's wait for it to come back online.\n    if (!requests.isPaused) {\n      requests.pause();\n      window.addEventListener('online', () => {\n        requests.resume();\n      }, {\n        once: true\n      });\n    }\n  } else {\n    // Other error code means the request can be retried later.\n    const next = retryDelayIterator.next();\n    if (next == null || next.done) {\n      return false;\n    }\n    await new Promise(resolve => setTimeout(resolve, next.value));\n  }\n  return true;\n}\nasync function _nonMultipartUpload2(file, chunk, signal) {\n  const {\n    method = 'POST',\n    url,\n    fields,\n    headers\n  } = await _classPrivateFieldLooseBase(this, _getUploadParameters)[_getUploadParameters](_classPrivateFieldLooseBase(this, _getFile)[_getFile](file), {\n    signal\n  }).abortOn(signal);\n  let body;\n  const data = chunk.getData();\n  if (method.toUpperCase() === 'POST') {\n    const formData = new FormData();\n    Object.entries(fields).forEach(_ref2 => {\n      let [key, value] = _ref2;\n      return formData.set(key, value);\n    });\n    formData.set('file', data);\n    body = formData;\n  } else {\n    body = data;\n  }\n  const {\n    onProgress,\n    onComplete\n  } = chunk;\n  const result = await _classPrivateFieldLooseBase(this, _uploadPartBytes)[_uploadPartBytes]({\n    signature: {\n      url,\n      headers,\n      method\n    },\n    body,\n    size: data.size,\n    onProgress,\n    onComplete,\n    signal\n  }).abortOn(signal); // todo this doesn't make sense\n\n  // location will be missing from result if CORS is not correctly set up on the bucket.\n  return 'location' in result ? result : {\n    // todo `url` is not really the final location URL of the resulting file, it's just the base URL of the bucket\n    // https://github.com/transloadit/uppy/issues/5388\n    location: removeMetadataFromURL(url),\n    ...result\n  };\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/aws-s3/lib/HTTPCommunicationQueue.js?");

/***/ }),

/***/ "./node_modules/@uppy/aws-s3/lib/MultipartUploader.js":
/*!************************************************************!*\
  !*** ./node_modules/@uppy/aws-s3/lib/MultipartUploader.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   pausingUploadReason: () => (/* binding */ pausingUploadReason)\n/* harmony export */ });\n/* harmony import */ var _uppy_utils_lib_AbortController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uppy/utils/lib/AbortController */ \"./node_modules/@uppy/utils/lib/AbortController.js\");\nfunction _classPrivateFieldLooseBase(e, t) { if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\"); return e; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(e) { return \"__private_\" + id++ + \"_\" + e; }\n\nconst MB = 1024 * 1024;\nconst defaultOptions = {\n  getChunkSize(file) {\n    return Math.ceil(file.size / 10000);\n  },\n  onProgress() {},\n  onPartComplete() {},\n  onSuccess() {},\n  onError(err) {\n    throw err;\n  }\n};\nfunction ensureInt(value) {\n  if (typeof value === 'string') {\n    // @ts-expect-error TS is not able to recognize it's fine.\n    return parseInt(value, 10);\n  }\n  if (typeof value === 'number') {\n    // @ts-expect-error TS is not able to recognize it's fine.\n    return value;\n  }\n  throw new TypeError('Expected a number');\n}\nconst pausingUploadReason = Symbol('pausing upload, not an actual error');\n\n/**\n * A MultipartUploader instance is used per file upload to determine whether a\n * upload should be done as multipart or as a regular S3 upload\n * (based on the user-provided `shouldUseMultipart` option value) and to manage\n * the chunk splitting.\n */\nvar _abortController = /*#__PURE__*/_classPrivateFieldLooseKey(\"abortController\");\nvar _chunks = /*#__PURE__*/_classPrivateFieldLooseKey(\"chunks\");\nvar _chunkState = /*#__PURE__*/_classPrivateFieldLooseKey(\"chunkState\");\nvar _data = /*#__PURE__*/_classPrivateFieldLooseKey(\"data\");\nvar _file = /*#__PURE__*/_classPrivateFieldLooseKey(\"file\");\nvar _uploadHasStarted = /*#__PURE__*/_classPrivateFieldLooseKey(\"uploadHasStarted\");\nvar _onError = /*#__PURE__*/_classPrivateFieldLooseKey(\"onError\");\nvar _onSuccess = /*#__PURE__*/_classPrivateFieldLooseKey(\"onSuccess\");\nvar _shouldUseMultipart = /*#__PURE__*/_classPrivateFieldLooseKey(\"shouldUseMultipart\");\nvar _isRestoring = /*#__PURE__*/_classPrivateFieldLooseKey(\"isRestoring\");\nvar _onReject = /*#__PURE__*/_classPrivateFieldLooseKey(\"onReject\");\nvar _maxMultipartParts = /*#__PURE__*/_classPrivateFieldLooseKey(\"maxMultipartParts\");\nvar _minPartSize = /*#__PURE__*/_classPrivateFieldLooseKey(\"minPartSize\");\nvar _initChunks = /*#__PURE__*/_classPrivateFieldLooseKey(\"initChunks\");\nvar _createUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"createUpload\");\nvar _resumeUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"resumeUpload\");\nvar _onPartProgress = /*#__PURE__*/_classPrivateFieldLooseKey(\"onPartProgress\");\nvar _onPartComplete = /*#__PURE__*/_classPrivateFieldLooseKey(\"onPartComplete\");\nvar _abortUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"abortUpload\");\nclass MultipartUploader {\n  constructor(data, options) {\n    var _this$options, _this$options$getChun;\n    Object.defineProperty(this, _abortUpload, {\n      value: _abortUpload2\n    });\n    Object.defineProperty(this, _resumeUpload, {\n      value: _resumeUpload2\n    });\n    Object.defineProperty(this, _createUpload, {\n      value: _createUpload2\n    });\n    // initChunks checks the user preference for using multipart uploads (opts.shouldUseMultipart)\n    // and calculates the optimal part size. When using multipart part uploads every part except for the last has\n    // to be at least 5 MB and there can be no more than 10K parts.\n    // This means we sometimes need to change the preferred part size from the user in order to meet these requirements.\n    Object.defineProperty(this, _initChunks, {\n      value: _initChunks2\n    });\n    Object.defineProperty(this, _abortController, {\n      writable: true,\n      value: new _uppy_utils_lib_AbortController__WEBPACK_IMPORTED_MODULE_0__.AbortController()\n    });\n    Object.defineProperty(this, _chunks, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _chunkState, {\n      writable: true,\n      value: []\n    });\n    /**\n     * The (un-chunked) data to upload.\n     */\n    Object.defineProperty(this, _data, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _file, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _uploadHasStarted, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _onError, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _onSuccess, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _shouldUseMultipart, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isRestoring, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _onReject, {\n      writable: true,\n      value: err => (err == null ? void 0 : err.cause) === pausingUploadReason ? null : _classPrivateFieldLooseBase(this, _onError)[_onError](err)\n    });\n    Object.defineProperty(this, _maxMultipartParts, {\n      writable: true,\n      value: 10000\n    });\n    Object.defineProperty(this, _minPartSize, {\n      writable: true,\n      value: 5 * MB\n    });\n    Object.defineProperty(this, _onPartProgress, {\n      writable: true,\n      value: index => ev => {\n        if (!ev.lengthComputable) return;\n        _classPrivateFieldLooseBase(this, _chunkState)[_chunkState][index].uploaded = ensureInt(ev.loaded);\n        const totalUploaded = _classPrivateFieldLooseBase(this, _chunkState)[_chunkState].reduce((n, c) => n + c.uploaded, 0);\n        this.options.onProgress(totalUploaded, _classPrivateFieldLooseBase(this, _data)[_data].size);\n      }\n    });\n    Object.defineProperty(this, _onPartComplete, {\n      writable: true,\n      value: index => etag => {\n        // This avoids the net::ERR_OUT_OF_MEMORY in Chromium Browsers.\n        _classPrivateFieldLooseBase(this, _chunks)[_chunks][index] = null;\n        _classPrivateFieldLooseBase(this, _chunkState)[_chunkState][index].etag = etag;\n        _classPrivateFieldLooseBase(this, _chunkState)[_chunkState][index].done = true;\n        const part = {\n          PartNumber: index + 1,\n          ETag: etag\n        };\n        this.options.onPartComplete(part);\n      }\n    });\n    this.options = {\n      ...defaultOptions,\n      ...options\n    };\n    // Use default `getChunkSize` if it was null or something\n    (_this$options$getChun = (_this$options = this.options).getChunkSize) != null ? _this$options$getChun : _this$options.getChunkSize = defaultOptions.getChunkSize;\n    _classPrivateFieldLooseBase(this, _data)[_data] = data;\n    _classPrivateFieldLooseBase(this, _file)[_file] = options.file;\n    _classPrivateFieldLooseBase(this, _onSuccess)[_onSuccess] = this.options.onSuccess;\n    _classPrivateFieldLooseBase(this, _onError)[_onError] = this.options.onError;\n    _classPrivateFieldLooseBase(this, _shouldUseMultipart)[_shouldUseMultipart] = this.options.shouldUseMultipart;\n\n    // When we are restoring an upload, we already have an UploadId and a Key. Otherwise\n    // we need to call `createMultipartUpload` to get an `uploadId` and a `key`.\n    // Non-multipart uploads are not restorable.\n    _classPrivateFieldLooseBase(this, _isRestoring)[_isRestoring] = options.uploadId && options.key;\n    _classPrivateFieldLooseBase(this, _initChunks)[_initChunks]();\n  }\n  start() {\n    if (_classPrivateFieldLooseBase(this, _uploadHasStarted)[_uploadHasStarted]) {\n      if (!_classPrivateFieldLooseBase(this, _abortController)[_abortController].signal.aborted) _classPrivateFieldLooseBase(this, _abortController)[_abortController].abort(pausingUploadReason);\n      _classPrivateFieldLooseBase(this, _abortController)[_abortController] = new _uppy_utils_lib_AbortController__WEBPACK_IMPORTED_MODULE_0__.AbortController();\n      _classPrivateFieldLooseBase(this, _resumeUpload)[_resumeUpload]();\n    } else if (_classPrivateFieldLooseBase(this, _isRestoring)[_isRestoring]) {\n      this.options.companionComm.restoreUploadFile(_classPrivateFieldLooseBase(this, _file)[_file], {\n        uploadId: this.options.uploadId,\n        key: this.options.key\n      });\n      _classPrivateFieldLooseBase(this, _resumeUpload)[_resumeUpload]();\n    } else {\n      _classPrivateFieldLooseBase(this, _createUpload)[_createUpload]();\n    }\n  }\n  pause() {\n    _classPrivateFieldLooseBase(this, _abortController)[_abortController].abort(pausingUploadReason);\n    // Swap it out for a new controller, because this instance may be resumed later.\n    _classPrivateFieldLooseBase(this, _abortController)[_abortController] = new _uppy_utils_lib_AbortController__WEBPACK_IMPORTED_MODULE_0__.AbortController();\n  }\n  abort(opts) {\n    if (opts != null && opts.really) _classPrivateFieldLooseBase(this, _abortUpload)[_abortUpload]();else this.pause();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  [Symbol.for('uppy test: getChunkState')]() {\n    return _classPrivateFieldLooseBase(this, _chunkState)[_chunkState];\n  }\n}\nfunction _initChunks2() {\n  const fileSize = _classPrivateFieldLooseBase(this, _data)[_data].size;\n  const shouldUseMultipart = typeof _classPrivateFieldLooseBase(this, _shouldUseMultipart)[_shouldUseMultipart] === 'function' ? _classPrivateFieldLooseBase(this, _shouldUseMultipart)[_shouldUseMultipart](_classPrivateFieldLooseBase(this, _file)[_file]) : Boolean(_classPrivateFieldLooseBase(this, _shouldUseMultipart)[_shouldUseMultipart]);\n  if (shouldUseMultipart && fileSize > _classPrivateFieldLooseBase(this, _minPartSize)[_minPartSize]) {\n    // At least 5MB per request:\n    let chunkSize = Math.max(this.options.getChunkSize(_classPrivateFieldLooseBase(this, _data)[_data]), // Math.max can take undefined but TS does not think so\n    _classPrivateFieldLooseBase(this, _minPartSize)[_minPartSize]);\n    let arraySize = Math.floor(fileSize / chunkSize);\n\n    // At most 10k requests per file:\n    if (arraySize > _classPrivateFieldLooseBase(this, _maxMultipartParts)[_maxMultipartParts]) {\n      arraySize = _classPrivateFieldLooseBase(this, _maxMultipartParts)[_maxMultipartParts];\n      chunkSize = fileSize / _classPrivateFieldLooseBase(this, _maxMultipartParts)[_maxMultipartParts];\n    }\n    _classPrivateFieldLooseBase(this, _chunks)[_chunks] = Array(arraySize);\n    for (let offset = 0, j = 0; offset < fileSize; offset += chunkSize, j++) {\n      const end = Math.min(fileSize, offset + chunkSize);\n\n      // Defer data fetching/slicing until we actually need the data, because it's slow if we have a lot of files\n      const getData = () => {\n        const i2 = offset;\n        return _classPrivateFieldLooseBase(this, _data)[_data].slice(i2, end);\n      };\n      _classPrivateFieldLooseBase(this, _chunks)[_chunks][j] = {\n        getData,\n        onProgress: _classPrivateFieldLooseBase(this, _onPartProgress)[_onPartProgress](j),\n        onComplete: _classPrivateFieldLooseBase(this, _onPartComplete)[_onPartComplete](j),\n        shouldUseMultipart\n      };\n      if (_classPrivateFieldLooseBase(this, _isRestoring)[_isRestoring]) {\n        const size = offset + chunkSize > fileSize ? fileSize - offset : chunkSize;\n        // setAsUploaded is called by listPart, to keep up-to-date the\n        // quantity of data that is left to actually upload.\n        _classPrivateFieldLooseBase(this, _chunks)[_chunks][j].setAsUploaded = () => {\n          _classPrivateFieldLooseBase(this, _chunks)[_chunks][j] = null;\n          _classPrivateFieldLooseBase(this, _chunkState)[_chunkState][j].uploaded = size;\n        };\n      }\n    }\n  } else {\n    _classPrivateFieldLooseBase(this, _chunks)[_chunks] = [{\n      getData: () => _classPrivateFieldLooseBase(this, _data)[_data],\n      onProgress: _classPrivateFieldLooseBase(this, _onPartProgress)[_onPartProgress](0),\n      onComplete: _classPrivateFieldLooseBase(this, _onPartComplete)[_onPartComplete](0),\n      shouldUseMultipart\n    }];\n  }\n  _classPrivateFieldLooseBase(this, _chunkState)[_chunkState] = _classPrivateFieldLooseBase(this, _chunks)[_chunks].map(() => ({\n    uploaded: 0\n  }));\n}\nfunction _createUpload2() {\n  this.options.companionComm.uploadFile(_classPrivateFieldLooseBase(this, _file)[_file], _classPrivateFieldLooseBase(this, _chunks)[_chunks], _classPrivateFieldLooseBase(this, _abortController)[_abortController].signal).then(_classPrivateFieldLooseBase(this, _onSuccess)[_onSuccess], _classPrivateFieldLooseBase(this, _onReject)[_onReject]);\n  _classPrivateFieldLooseBase(this, _uploadHasStarted)[_uploadHasStarted] = true;\n}\nfunction _resumeUpload2() {\n  this.options.companionComm.resumeUploadFile(_classPrivateFieldLooseBase(this, _file)[_file], _classPrivateFieldLooseBase(this, _chunks)[_chunks], _classPrivateFieldLooseBase(this, _abortController)[_abortController].signal).then(_classPrivateFieldLooseBase(this, _onSuccess)[_onSuccess], _classPrivateFieldLooseBase(this, _onReject)[_onReject]);\n}\nfunction _abortUpload2() {\n  _classPrivateFieldLooseBase(this, _abortController)[_abortController].abort();\n  this.options.companionComm.abortFileUpload(_classPrivateFieldLooseBase(this, _file)[_file]).catch(err => this.options.log(err));\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MultipartUploader);\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/aws-s3/lib/MultipartUploader.js?");

/***/ }),

/***/ "./node_modules/@uppy/aws-s3/lib/createSignedURL.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uppy/aws-s3/lib/createSignedURL.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ createSignedURL)\n/* harmony export */ });\n/**\n * Create a canonical request by concatenating the following strings, separated\n * by newline characters. This helps ensure that the signature that you\n * calculate and the signature that AWS calculates can match.\n *\n * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/create-signed-request.html#create-canonical-request\n *\n * @param param0\n * @param param0.method – The HTTP method.\n * @param param0.CanonicalUri – The URI-encoded version of the absolute\n * path component URL (everything between the host and the question mark\n * character (?) that starts the query string parameters). If the absolute path\n * is empty, use a forward slash character (/).\n * @param param0.CanonicalQueryString – The URL-encoded query string\n * parameters, separated by ampersands (&). Percent-encode reserved characters,\n * including the space character. Encode names and values separately. If there\n * are empty parameters, append the equals sign to the parameter name before\n * encoding. After encoding, sort the parameters alphabetically by key name. If\n * there is no query string, use an empty string (\"\").\n * @param param0.SignedHeaders – The request headers,\n * that will be signed, and their values, separated by newline characters.\n * For the values, trim any leading or trailing spaces, convert sequential\n * spaces to a single space, and separate the values for a multi-value header\n * using commas. You must include the host header (HTTP/1.1), and any x-amz-*\n * headers in the signature. You can optionally include other standard headers\n * in the signature, such as content-type.\n * @param param0.HashedPayload – A string created using the payload in\n * the body of the HTTP request as input to a hash function. This string uses\n * lowercase hexadecimal characters. If the payload is empty, use an empty\n * string as the input to the hash function.\n */\nfunction createCanonicalRequest(_ref) {\n  let {\n    method = 'PUT',\n    CanonicalUri = '/',\n    CanonicalQueryString = '',\n    SignedHeaders,\n    HashedPayload\n  } = _ref;\n  const headerKeys = Object.keys(SignedHeaders).map(k => k.toLowerCase()).sort();\n  return [method, CanonicalUri, CanonicalQueryString, ...headerKeys.map(k => `${k}:${SignedHeaders[k]}`), '', headerKeys.join(';'), HashedPayload].join('\\n');\n}\nconst ec = new TextEncoder();\nconst algorithm = {\n  name: 'HMAC',\n  hash: 'SHA-256'\n};\nasync function digest(data) {\n  const {\n    subtle\n  } = globalThis.crypto;\n  return subtle.digest(algorithm.hash, ec.encode(data));\n}\nasync function generateHmacKey(secret) {\n  const {\n    subtle\n  } = globalThis.crypto;\n  return subtle.importKey('raw', typeof secret === 'string' ? ec.encode(secret) : secret, algorithm, false, ['sign']);\n}\nfunction arrayBufferToHexString(arrayBuffer) {\n  const byteArray = new Uint8Array(arrayBuffer);\n  let hexString = '';\n  for (let i = 0; i < byteArray.length; i++) {\n    hexString += byteArray[i].toString(16).padStart(2, '0');\n  }\n  return hexString;\n}\nasync function hash(key, data) {\n  const {\n    subtle\n  } = globalThis.crypto;\n  return subtle.sign(algorithm, await generateHmacKey(key), ec.encode(data));\n}\n\n/**\n * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/create-signed-request.html\n */\nasync function createSignedURL(_ref2) {\n  let {\n    accountKey,\n    accountSecret,\n    sessionToken,\n    bucketName,\n    Key,\n    Region,\n    expires,\n    uploadId,\n    partNumber\n  } = _ref2;\n  const Service = 's3';\n  const host = `${Service}.${Region}.amazonaws.com`;\n  /**\n   * List of char out of `encodeURI()` is taken from ECMAScript spec.\n   * Note that the `/` character is purposefully not included in list below.\n   *\n   * @see https://tc39.es/ecma262/#sec-encodeuri-uri\n   */\n  const CanonicalUri = `/${bucketName}/${encodeURI(Key).replace(/[;?:@&=+$,#!'()*]/g, c => `%${c.charCodeAt(0).toString(16).toUpperCase()}`)}`;\n  const payload = 'UNSIGNED-PAYLOAD';\n  const requestDateTime = new Date().toISOString().replace(/[-:]|\\.\\d+/g, ''); // YYYYMMDDTHHMMSSZ\n  const date = requestDateTime.slice(0, 8); // YYYYMMDD\n  const scope = `${date}/${Region}/${Service}/aws4_request`;\n  const url = new URL(`https://${host}${CanonicalUri}`);\n  // N.B.: URL search params needs to be added in the ASCII order\n  url.searchParams.set('X-Amz-Algorithm', 'AWS4-HMAC-SHA256');\n  url.searchParams.set('X-Amz-Content-Sha256', payload);\n  url.searchParams.set('X-Amz-Credential', `${accountKey}/${scope}`);\n  url.searchParams.set('X-Amz-Date', requestDateTime);\n  url.searchParams.set('X-Amz-Expires', expires);\n  // We are signing on the client, so we expect there's going to be a session token:\n  url.searchParams.set('X-Amz-Security-Token', sessionToken);\n  url.searchParams.set('X-Amz-SignedHeaders', 'host');\n  // Those two are present only for Multipart Uploads:\n  if (partNumber) url.searchParams.set('partNumber', partNumber);\n  if (uploadId) url.searchParams.set('uploadId', uploadId);\n  url.searchParams.set('x-id', partNumber && uploadId ? 'UploadPart' : 'PutObject');\n\n  // Step 1: Create a canonical request\n  const canonical = createCanonicalRequest({\n    CanonicalUri,\n    CanonicalQueryString: url.search.slice(1),\n    SignedHeaders: {\n      host\n    },\n    HashedPayload: payload\n  });\n\n  // Step 2: Create a hash of the canonical request\n  const hashedCanonical = arrayBufferToHexString(await digest(canonical));\n\n  // Step 3: Create a string to sign\n  const stringToSign = [`AWS4-HMAC-SHA256`,\n  // The algorithm used to create the hash of the canonical request.\n  requestDateTime,\n  // The date and time used in the credential scope.\n  scope,\n  // The credential scope. This restricts the resulting signature to the specified Region and service.\n  hashedCanonical // The hash of the canonical request.\n  ].join('\\n');\n\n  // Step 4: Calculate the signature\n  const kDate = await hash(`AWS4${accountSecret}`, date);\n  const kRegion = await hash(kDate, Region);\n  const kService = await hash(kRegion, Service);\n  const kSigning = await hash(kService, 'aws4_request');\n  const signature = arrayBufferToHexString(await hash(kSigning, stringToSign));\n\n  // Step 5: Add the signature to the request\n  url.searchParams.set('X-Amz-Signature', signature);\n  return url;\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/aws-s3/lib/createSignedURL.js?");

/***/ }),

/***/ "./node_modules/@uppy/aws-s3/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@uppy/aws-s3/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AwsS3Multipart)\n/* harmony export */ });\n/* harmony import */ var _uppy_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @uppy/core */ \"./node_modules/@uppy/core/lib/BasePlugin.js\");\n/* harmony import */ var _uppy_companion_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uppy/companion-client */ \"./node_modules/@uppy/companion-client/lib/index.js\");\n/* harmony import */ var _uppy_core_lib_EventManager_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @uppy/core/lib/EventManager.js */ \"./node_modules/@uppy/core/lib/EventManager.js\");\n/* harmony import */ var _uppy_utils_lib_RateLimitedQueue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @uppy/utils/lib/RateLimitedQueue */ \"./node_modules/@uppy/utils/lib/RateLimitedQueue.js\");\n/* harmony import */ var _uppy_utils_lib_fileFilters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @uppy/utils/lib/fileFilters */ \"./node_modules/@uppy/utils/lib/fileFilters.js\");\n/* harmony import */ var _uppy_utils_lib_AbortController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @uppy/utils/lib/AbortController */ \"./node_modules/@uppy/utils/lib/AbortController.js\");\n/* harmony import */ var _uppy_utils_lib_getAllowedMetaFields__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @uppy/utils/lib/getAllowedMetaFields */ \"./node_modules/@uppy/utils/lib/getAllowedMetaFields.js\");\n/* harmony import */ var _MultipartUploader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MultipartUploader.js */ \"./node_modules/@uppy/aws-s3/lib/MultipartUploader.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@uppy/aws-s3/lib/utils.js\");\n/* harmony import */ var _createSignedURL_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./createSignedURL.js */ \"./node_modules/@uppy/aws-s3/lib/createSignedURL.js\");\n/* harmony import */ var _HTTPCommunicationQueue_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./HTTPCommunicationQueue.js */ \"./node_modules/@uppy/aws-s3/lib/HTTPCommunicationQueue.js\");\nfunction _classPrivateFieldLooseBase(e, t) { if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\"); return e; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(e) { return \"__private_\" + id++ + \"_\" + e; }\n\n\n\n\n\n\n\n\n\n\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore We don't want TS to generate types for the package.json\nconst packageJson = {\n  \"version\": \"4.2.1\"\n};\nfunction assertServerError(res) {\n  if (res != null && res.error) {\n    const error = new Error(res.message);\n    Object.assign(error, res.error);\n    throw error;\n  }\n  return res;\n}\n/**\n * Computes the expiry time for a request signed with temporary credentials. If\n * no expiration was provided, or an invalid value (e.g. in the past) is\n * provided, undefined is returned. This function assumes the client clock is in\n * sync with the remote server, which is a requirement for the signature to be\n * validated for AWS anyway.\n */\nfunction getExpiry(credentials) {\n  const expirationDate = credentials.Expiration;\n  if (expirationDate) {\n    const timeUntilExpiry = Math.floor((new Date(expirationDate) - Date.now()) / 1000);\n    if (timeUntilExpiry > 9) {\n      return timeUntilExpiry;\n    }\n  }\n  return undefined;\n}\nfunction getAllowedMetadata(_ref) {\n  let {\n    meta,\n    allowedMetaFields,\n    querify = false\n  } = _ref;\n  const metaFields = allowedMetaFields != null ? allowedMetaFields : Object.keys(meta);\n  if (!meta) return {};\n  return Object.fromEntries(metaFields.filter(key => meta[key] != null).map(key => {\n    const realKey = querify ? `metadata[${key}]` : key;\n    const value = String(meta[key]);\n    return [realKey, value];\n  }));\n}\nconst defaultOptions = {\n  allowedMetaFields: true,\n  limit: 6,\n  getTemporarySecurityCredentials: false,\n  // eslint-disable-next-line no-bitwise\n  shouldUseMultipart: file =>\n  // eslint-disable-next-line no-bitwise\n  file.size >> 10 >> 10 > 100,\n  retryDelays: [0, 1000, 3000, 5000]\n};\nvar _companionCommunicationQueue = /*#__PURE__*/_classPrivateFieldLooseKey(\"companionCommunicationQueue\");\nvar _client = /*#__PURE__*/_classPrivateFieldLooseKey(\"client\");\nvar _setClient = /*#__PURE__*/_classPrivateFieldLooseKey(\"setClient\");\nvar _assertHost = /*#__PURE__*/_classPrivateFieldLooseKey(\"assertHost\");\nvar _cachedTemporaryCredentials = /*#__PURE__*/_classPrivateFieldLooseKey(\"cachedTemporaryCredentials\");\nvar _getTemporarySecurityCredentials = /*#__PURE__*/_classPrivateFieldLooseKey(\"getTemporarySecurityCredentials\");\nvar _setS3MultipartState = /*#__PURE__*/_classPrivateFieldLooseKey(\"setS3MultipartState\");\nvar _getFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"getFile\");\nvar _uploadLocalFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"uploadLocalFile\");\nvar _getCompanionClientArgs = /*#__PURE__*/_classPrivateFieldLooseKey(\"getCompanionClientArgs\");\nvar _upload = /*#__PURE__*/_classPrivateFieldLooseKey(\"upload\");\nvar _setCompanionHeaders = /*#__PURE__*/_classPrivateFieldLooseKey(\"setCompanionHeaders\");\nvar _setResumableUploadsCapability = /*#__PURE__*/_classPrivateFieldLooseKey(\"setResumableUploadsCapability\");\nvar _resetResumableCapability = /*#__PURE__*/_classPrivateFieldLooseKey(\"resetResumableCapability\");\nclass AwsS3Multipart extends _uppy_core__WEBPACK_IMPORTED_MODULE_9__[\"default\"] {\n  constructor(uppy, _opts) {\n    var _rateLimitedQueue;\n    super(uppy, {\n      ...defaultOptions,\n      uploadPartBytes: AwsS3Multipart.uploadPartBytes,\n      createMultipartUpload: null,\n      listParts: null,\n      abortMultipartUpload: null,\n      completeMultipartUpload: null,\n      signPart: null,\n      getUploadParameters: null,\n      ..._opts\n    });\n    // We need the `as any` here because of the dynamic default options.\n    // eslint-disable-next-line class-methods-use-this\n    Object.defineProperty(this, _getCompanionClientArgs, {\n      value: _getCompanionClientArgs2\n    });\n    Object.defineProperty(this, _uploadLocalFile, {\n      value: _uploadLocalFile2\n    });\n    Object.defineProperty(this, _getTemporarySecurityCredentials, {\n      value: _getTemporarySecurityCredentials2\n    });\n    Object.defineProperty(this, _assertHost, {\n      value: _assertHost2\n    });\n    Object.defineProperty(this, _setClient, {\n      value: _setClient2\n    });\n    Object.defineProperty(this, _companionCommunicationQueue, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _client, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _cachedTemporaryCredentials, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _setS3MultipartState, {\n      writable: true,\n      value: (file, _ref2) => {\n        let {\n          key,\n          uploadId\n        } = _ref2;\n        const cFile = this.uppy.getFile(file.id);\n        if (cFile == null) {\n          // file was removed from store\n          return;\n        }\n        this.uppy.setFileState(file.id, {\n          s3Multipart: {\n            ...cFile.s3Multipart,\n            key,\n            uploadId\n          }\n        });\n      }\n    });\n    Object.defineProperty(this, _getFile, {\n      writable: true,\n      value: file => {\n        return this.uppy.getFile(file.id) || file;\n      }\n    });\n    Object.defineProperty(this, _upload, {\n      writable: true,\n      value: async fileIDs => {\n        if (fileIDs.length === 0) return undefined;\n        const files = this.uppy.getFilesByIds(fileIDs);\n        const filesFiltered = (0,_uppy_utils_lib_fileFilters__WEBPACK_IMPORTED_MODULE_2__.filterNonFailedFiles)(files);\n        const filesToEmit = (0,_uppy_utils_lib_fileFilters__WEBPACK_IMPORTED_MODULE_2__.filterFilesToEmitUploadStarted)(filesFiltered);\n        this.uppy.emit('upload-start', filesToEmit);\n        const promises = filesFiltered.map(file => {\n          if (file.isRemote) {\n            const getQueue = () => this.requests;\n            _classPrivateFieldLooseBase(this, _setResumableUploadsCapability)[_setResumableUploadsCapability](false);\n            const controller = new AbortController();\n            const removedHandler = removedFile => {\n              if (removedFile.id === file.id) controller.abort();\n            };\n            this.uppy.on('file-removed', removedHandler);\n            const uploadPromise = this.uppy.getRequestClientForFile(file).uploadRemoteFile(file, _classPrivateFieldLooseBase(this, _getCompanionClientArgs)[_getCompanionClientArgs](file), {\n              signal: controller.signal,\n              getQueue\n            });\n            this.requests.wrapSyncFunction(() => {\n              this.uppy.off('file-removed', removedHandler);\n            }, {\n              priority: -1\n            })();\n            return uploadPromise;\n          }\n          return _classPrivateFieldLooseBase(this, _uploadLocalFile)[_uploadLocalFile](file);\n        });\n        const upload = await Promise.all(promises);\n        // After the upload is done, another upload may happen with only local files.\n        // We reset the capability so that the next upload can use resumable uploads.\n        _classPrivateFieldLooseBase(this, _setResumableUploadsCapability)[_setResumableUploadsCapability](true);\n        return upload;\n      }\n    });\n    Object.defineProperty(this, _setCompanionHeaders, {\n      writable: true,\n      value: () => {\n        var _classPrivateFieldLoo;\n        (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _client)[_client]) == null || _classPrivateFieldLoo.setCompanionHeaders(this.opts.headers);\n      }\n    });\n    Object.defineProperty(this, _setResumableUploadsCapability, {\n      writable: true,\n      value: boolean => {\n        const {\n          capabilities\n        } = this.uppy.getState();\n        this.uppy.setState({\n          capabilities: {\n            ...capabilities,\n            resumableUploads: boolean\n          }\n        });\n      }\n    });\n    Object.defineProperty(this, _resetResumableCapability, {\n      writable: true,\n      value: () => {\n        _classPrivateFieldLooseBase(this, _setResumableUploadsCapability)[_setResumableUploadsCapability](true);\n      }\n    });\n    this.type = 'uploader';\n    this.id = this.opts.id || 'AwsS3Multipart';\n    _classPrivateFieldLooseBase(this, _setClient)[_setClient](_opts);\n    const dynamicDefaultOptions = {\n      createMultipartUpload: this.createMultipartUpload,\n      listParts: this.listParts,\n      abortMultipartUpload: this.abortMultipartUpload,\n      completeMultipartUpload: this.completeMultipartUpload,\n      signPart: _opts != null && _opts.getTemporarySecurityCredentials ? this.createSignedURL : this.signPart,\n      getUploadParameters: _opts != null && _opts.getTemporarySecurityCredentials ? this.createSignedURL : this.getUploadParameters\n    };\n    for (const key of Object.keys(dynamicDefaultOptions)) {\n      if (this.opts[key] == null) {\n        this.opts[key] = dynamicDefaultOptions[key].bind(this);\n      }\n    }\n\n    /**\n     * Simultaneous upload limiting is shared across all uploads with this plugin.\n     *\n     * @type {RateLimitedQueue}\n     */\n    this.requests = (_rateLimitedQueue = this.opts.rateLimitedQueue) != null ? _rateLimitedQueue : new _uppy_utils_lib_RateLimitedQueue__WEBPACK_IMPORTED_MODULE_1__.RateLimitedQueue(this.opts.limit);\n    _classPrivateFieldLooseBase(this, _companionCommunicationQueue)[_companionCommunicationQueue] = new _HTTPCommunicationQueue_js__WEBPACK_IMPORTED_MODULE_8__.HTTPCommunicationQueue(this.requests, this.opts, _classPrivateFieldLooseBase(this, _setS3MultipartState)[_setS3MultipartState], _classPrivateFieldLooseBase(this, _getFile)[_getFile]);\n    this.uploaders = Object.create(null);\n    this.uploaderEvents = Object.create(null);\n  }\n  [Symbol.for('uppy test: getClient')]() {\n    return _classPrivateFieldLooseBase(this, _client)[_client];\n  }\n  setOptions(newOptions) {\n    _classPrivateFieldLooseBase(this, _companionCommunicationQueue)[_companionCommunicationQueue].setOptions(newOptions);\n    super.setOptions(newOptions);\n    _classPrivateFieldLooseBase(this, _setClient)[_setClient](newOptions);\n  }\n\n  /**\n   * Clean up all references for a file's upload: the MultipartUploader instance,\n   * any events related to the file, and the Companion WebSocket connection.\n   *\n   * Set `opts.abort` to tell S3 that the multipart upload is cancelled and must be removed.\n   * This should be done when the user cancels the upload, not when the upload is completed or errored.\n   */\n  resetUploaderReferences(fileID, opts) {\n    if (this.uploaders[fileID]) {\n      this.uploaders[fileID].abort({\n        really: (opts == null ? void 0 : opts.abort) || false\n      });\n      this.uploaders[fileID] = null;\n    }\n    if (this.uploaderEvents[fileID]) {\n      this.uploaderEvents[fileID].remove();\n      this.uploaderEvents[fileID] = null;\n    }\n  }\n  createMultipartUpload(file, signal) {\n    _classPrivateFieldLooseBase(this, _assertHost)[_assertHost]('createMultipartUpload');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.throwIfAborted)(signal);\n    const allowedMetaFields = (0,_uppy_utils_lib_getAllowedMetaFields__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.opts.allowedMetaFields, file.meta);\n    const metadata = getAllowedMetadata({\n      meta: file.meta,\n      allowedMetaFields\n    });\n    return _classPrivateFieldLooseBase(this, _client)[_client].post('s3/multipart', {\n      filename: file.name,\n      type: file.type,\n      metadata\n    }, {\n      signal\n    }).then(assertServerError);\n  }\n  listParts(file, _ref3, oldSignal) {\n    var _signal;\n    let {\n      key,\n      uploadId,\n      signal\n    } = _ref3;\n    (_signal = signal) != null ? _signal : signal = oldSignal; // eslint-disable-line no-param-reassign\n    _classPrivateFieldLooseBase(this, _assertHost)[_assertHost]('listParts');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.throwIfAborted)(signal);\n    const filename = encodeURIComponent(key);\n    return _classPrivateFieldLooseBase(this, _client)[_client].get(`s3/multipart/${encodeURIComponent(uploadId)}?key=${filename}`, {\n      signal\n    }).then(assertServerError);\n  }\n  completeMultipartUpload(file, _ref4, oldSignal) {\n    var _signal2;\n    let {\n      key,\n      uploadId,\n      parts,\n      signal\n    } = _ref4;\n    (_signal2 = signal) != null ? _signal2 : signal = oldSignal; // eslint-disable-line no-param-reassign\n    _classPrivateFieldLooseBase(this, _assertHost)[_assertHost]('completeMultipartUpload');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.throwIfAborted)(signal);\n    const filename = encodeURIComponent(key);\n    const uploadIdEnc = encodeURIComponent(uploadId);\n    return _classPrivateFieldLooseBase(this, _client)[_client].post(`s3/multipart/${uploadIdEnc}/complete?key=${filename}`, {\n      parts: parts.map(_ref5 => {\n        let {\n          ETag,\n          PartNumber\n        } = _ref5;\n        return {\n          ETag,\n          PartNumber\n        };\n      })\n    }, {\n      signal\n    }).then(assertServerError);\n  }\n  async createSignedURL(file, options) {\n    const data = await _classPrivateFieldLooseBase(this, _getTemporarySecurityCredentials)[_getTemporarySecurityCredentials](options);\n    const expires = getExpiry(data.credentials) || 604800; // 604 800 is the max value accepted by AWS.\n\n    const {\n      uploadId,\n      key,\n      partNumber\n    } = options;\n\n    // Return an object in the correct shape.\n    return {\n      method: 'PUT',\n      expires,\n      fields: {},\n      url: `${await (0,_createSignedURL_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n        accountKey: data.credentials.AccessKeyId,\n        accountSecret: data.credentials.SecretAccessKey,\n        sessionToken: data.credentials.SessionToken,\n        expires,\n        bucketName: data.bucket,\n        Region: data.region,\n        Key: key != null ? key : `${crypto.randomUUID()}-${file.name}`,\n        uploadId,\n        partNumber\n      })}`,\n      // Provide content type header required by S3\n      headers: {\n        'Content-Type': file.type\n      }\n    };\n  }\n  signPart(file, _ref6) {\n    let {\n      uploadId,\n      key,\n      partNumber,\n      signal\n    } = _ref6;\n    _classPrivateFieldLooseBase(this, _assertHost)[_assertHost]('signPart');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.throwIfAborted)(signal);\n    if (uploadId == null || key == null || partNumber == null) {\n      throw new Error('Cannot sign without a key, an uploadId, and a partNumber');\n    }\n    const filename = encodeURIComponent(key);\n    return _classPrivateFieldLooseBase(this, _client)[_client].get(`s3/multipart/${encodeURIComponent(uploadId)}/${partNumber}?key=${filename}`, {\n      signal\n    }).then(assertServerError);\n  }\n  abortMultipartUpload(file, _ref7) {\n    let {\n      key,\n      uploadId,\n      signal\n    } = _ref7;\n    _classPrivateFieldLooseBase(this, _assertHost)[_assertHost]('abortMultipartUpload');\n    const filename = encodeURIComponent(key);\n    const uploadIdEnc = encodeURIComponent(uploadId);\n    return _classPrivateFieldLooseBase(this, _client)[_client].delete(`s3/multipart/${uploadIdEnc}?key=${filename}`, undefined, {\n      signal\n    }).then(assertServerError);\n  }\n  getUploadParameters(file, options) {\n    _classPrivateFieldLooseBase(this, _assertHost)[_assertHost]('getUploadParameters');\n    const {\n      meta\n    } = file;\n    const {\n      type,\n      name: filename\n    } = meta;\n    const allowedMetaFields = (0,_uppy_utils_lib_getAllowedMetaFields__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.opts.allowedMetaFields, file.meta);\n    const metadata = getAllowedMetadata({\n      meta,\n      allowedMetaFields,\n      querify: true\n    });\n    const query = new URLSearchParams({\n      filename,\n      type,\n      ...metadata\n    });\n    return _classPrivateFieldLooseBase(this, _client)[_client].get(`s3/params?${query}`, options);\n  }\n  static async uploadPartBytes(_ref8) {\n    let {\n      signature: {\n        url,\n        expires,\n        headers,\n        method = 'PUT'\n      },\n      body,\n      size = body.size,\n      onProgress,\n      onComplete,\n      signal\n    } = _ref8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.throwIfAborted)(signal);\n    if (url == null) {\n      throw new Error('Cannot upload to an undefined URL');\n    }\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open(method, url, true);\n      if (headers) {\n        Object.keys(headers).forEach(key => {\n          xhr.setRequestHeader(key, headers[key]);\n        });\n      }\n      xhr.responseType = 'text';\n      if (typeof expires === 'number') {\n        xhr.timeout = expires * 1000;\n      }\n      function onabort() {\n        xhr.abort();\n      }\n      function cleanup() {\n        signal == null || signal.removeEventListener('abort', onabort);\n      }\n      signal == null || signal.addEventListener('abort', onabort);\n      xhr.upload.addEventListener('progress', ev => {\n        onProgress(ev);\n      });\n      xhr.addEventListener('abort', () => {\n        cleanup();\n        reject((0,_uppy_utils_lib_AbortController__WEBPACK_IMPORTED_MODULE_3__.createAbortError)());\n      });\n      xhr.addEventListener('timeout', () => {\n        cleanup();\n        const error = new Error('Request has expired');\n        error.source = {\n          status: 403\n        };\n        reject(error);\n      });\n      xhr.addEventListener('load', () => {\n        cleanup();\n        if (xhr.status === 403 && xhr.responseText.includes('<Message>Request has expired</Message>')) {\n          const error = new Error('Request has expired');\n          error.source = xhr;\n          reject(error);\n          return;\n        }\n        if (xhr.status < 200 || xhr.status >= 300) {\n          const error = new Error('Non 2xx');\n          error.source = xhr;\n          reject(error);\n          return;\n        }\n        onProgress == null || onProgress({\n          loaded: size,\n          lengthComputable: true\n        });\n\n        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders#examples\n        const arr = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n        // @ts-expect-error null is allowed to avoid inherited properties\n        const headersMap = {\n          __proto__: null\n        };\n        for (const line of arr) {\n          const parts = line.split(': ');\n          const header = parts.shift();\n          const value = parts.join(': ');\n          headersMap[header] = value;\n        }\n        const {\n          etag,\n          location\n        } = headersMap;\n\n        // More info bucket settings when this is not present:\n        // https://github.com/transloadit/uppy/issues/5388#issuecomment-2464885562\n        if (method.toUpperCase() === 'POST' && location == null) {\n          // Not being able to read the Location header is not a fatal error.\n          // eslint-disable-next-line no-console\n          console.error('@uppy/aws-s3: Could not read the Location header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3/#setting-up-your-s3-bucket');\n        }\n        if (etag == null) {\n          // eslint-disable-next-line no-console\n          console.error('@uppy/aws-s3: Could not read the ETag header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3/#setting-up-your-s3-bucket');\n          return;\n        }\n        onComplete == null || onComplete(etag);\n        resolve({\n          ...headersMap,\n          ETag: etag // keep capitalised ETag for backwards compatiblity\n        });\n      });\n      xhr.addEventListener('error', ev => {\n        cleanup();\n        const error = new Error('Unknown error');\n        error.source = ev.target;\n        reject(error);\n      });\n      xhr.send(body);\n    });\n  }\n  install() {\n    _classPrivateFieldLooseBase(this, _setResumableUploadsCapability)[_setResumableUploadsCapability](true);\n    this.uppy.addPreProcessor(_classPrivateFieldLooseBase(this, _setCompanionHeaders)[_setCompanionHeaders]);\n    this.uppy.addUploader(_classPrivateFieldLooseBase(this, _upload)[_upload]);\n    this.uppy.on('cancel-all', _classPrivateFieldLooseBase(this, _resetResumableCapability)[_resetResumableCapability]);\n  }\n  uninstall() {\n    this.uppy.removePreProcessor(_classPrivateFieldLooseBase(this, _setCompanionHeaders)[_setCompanionHeaders]);\n    this.uppy.removeUploader(_classPrivateFieldLooseBase(this, _upload)[_upload]);\n    this.uppy.off('cancel-all', _classPrivateFieldLooseBase(this, _resetResumableCapability)[_resetResumableCapability]);\n  }\n}\nfunction _setClient2(opts) {\n  if (opts == null || !('endpoint' in opts || 'companionUrl' in opts || 'headers' in opts || 'companionHeaders' in opts || 'cookiesRule' in opts || 'companionCookiesRule' in opts)) return;\n  if ('companionUrl' in opts && !('endpoint' in opts)) {\n    this.uppy.log('`companionUrl` option has been removed in @uppy/aws-s3, use `endpoint` instead.', 'warning');\n  }\n  if ('companionHeaders' in opts && !('headers' in opts)) {\n    this.uppy.log('`companionHeaders` option has been removed in @uppy/aws-s3, use `headers` instead.', 'warning');\n  }\n  if ('companionCookiesRule' in opts && !('cookiesRule' in opts)) {\n    this.uppy.log('`companionCookiesRule` option has been removed in @uppy/aws-s3, use `cookiesRule` instead.', 'warning');\n  }\n  if ('endpoint' in opts) {\n    _classPrivateFieldLooseBase(this, _client)[_client] = new _uppy_companion_client__WEBPACK_IMPORTED_MODULE_0__.RequestClient(this.uppy, {\n      pluginId: this.id,\n      provider: 'AWS',\n      companionUrl: this.opts.endpoint,\n      companionHeaders: this.opts.headers,\n      companionCookiesRule: this.opts.cookiesRule\n    });\n  } else {\n    if ('headers' in opts) {\n      _classPrivateFieldLooseBase(this, _setCompanionHeaders)[_setCompanionHeaders]();\n    }\n    if ('cookiesRule' in opts) {\n      _classPrivateFieldLooseBase(this, _client)[_client].opts.companionCookiesRule = opts.cookiesRule;\n    }\n  }\n}\nfunction _assertHost2(method) {\n  if (!_classPrivateFieldLooseBase(this, _client)[_client]) {\n    throw new Error(`Expected a \\`endpoint\\` option containing a URL, or if you are not using Companion, a custom \\`${method}\\` implementation.`);\n  }\n}\nasync function _getTemporarySecurityCredentials2(options) {\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.throwIfAborted)(options == null ? void 0 : options.signal);\n  if (_classPrivateFieldLooseBase(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials] == null) {\n    const {\n      getTemporarySecurityCredentials\n    } = this.opts;\n    // We do not await it just yet, so concurrent calls do not try to override it:\n    if (getTemporarySecurityCredentials === true) {\n      _classPrivateFieldLooseBase(this, _assertHost)[_assertHost]('getTemporarySecurityCredentials');\n      _classPrivateFieldLooseBase(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials] = _classPrivateFieldLooseBase(this, _client)[_client].get('s3/sts', options).then(assertServerError);\n    } else {\n      _classPrivateFieldLooseBase(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials] = getTemporarySecurityCredentials(options);\n    }\n    _classPrivateFieldLooseBase(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials] = await _classPrivateFieldLooseBase(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials];\n    setTimeout(() => {\n      // At half the time left before expiration, we clear the cache. That's\n      // an arbitrary tradeoff to limit the number of requests made to the\n      // remote while limiting the risk of using an expired token in case the\n      // clocks are not exactly synced.\n      // The HTTP cache should be configured to ensure a client doesn't request\n      // more tokens than it needs, but this timeout provides a second layer of\n      // security in case the HTTP cache is disabled or misconfigured.\n      _classPrivateFieldLooseBase(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials] = null;\n    }, (getExpiry(_classPrivateFieldLooseBase(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials].credentials) || 0) * 500);\n  }\n  return _classPrivateFieldLooseBase(this, _cachedTemporaryCredentials)[_cachedTemporaryCredentials];\n}\nfunction _uploadLocalFile2(file) {\n  var _this = this;\n  return new Promise((resolve, reject) => {\n    const onProgress = (bytesUploaded, bytesTotal) => {\n      var _latestFile$progress$;\n      const latestFile = this.uppy.getFile(file.id);\n      this.uppy.emit('upload-progress', latestFile, {\n        uploadStarted: (_latestFile$progress$ = latestFile.progress.uploadStarted) != null ? _latestFile$progress$ : 0,\n        bytesUploaded,\n        bytesTotal\n      });\n    };\n    const onError = err => {\n      this.uppy.log(err);\n      this.uppy.emit('upload-error', file, err);\n      this.resetUploaderReferences(file.id);\n      reject(err);\n    };\n    const onSuccess = result => {\n      const uploadResp = {\n        body: {\n          ...result\n        },\n        status: 200,\n        uploadURL: result.location\n      };\n      this.resetUploaderReferences(file.id);\n      this.uppy.emit('upload-success', _classPrivateFieldLooseBase(this, _getFile)[_getFile](file), uploadResp);\n      if (result.location) {\n        this.uppy.log(`Download ${file.name} from ${result.location}`);\n      }\n      resolve();\n    };\n    const upload = new _MultipartUploader_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](file.data, {\n      // .bind to pass the file object to each handler.\n      companionComm: _classPrivateFieldLooseBase(this, _companionCommunicationQueue)[_companionCommunicationQueue],\n      log: function () {\n        return _this.uppy.log(...arguments);\n      },\n      getChunkSize: this.opts.getChunkSize ? this.opts.getChunkSize.bind(this) : undefined,\n      onProgress,\n      onError,\n      onSuccess,\n      onPartComplete: part => {\n        this.uppy.emit('s3-multipart:part-uploaded', _classPrivateFieldLooseBase(this, _getFile)[_getFile](file), part);\n      },\n      file,\n      shouldUseMultipart: this.opts.shouldUseMultipart,\n      ...file.s3Multipart\n    });\n    this.uploaders[file.id] = upload;\n    const eventManager = new _uppy_core_lib_EventManager_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"](this.uppy);\n    this.uploaderEvents[file.id] = eventManager;\n    eventManager.onFileRemove(file.id, removed => {\n      upload.abort();\n      this.resetUploaderReferences(file.id, {\n        abort: true\n      });\n      resolve(`upload ${removed} was removed`);\n    });\n    eventManager.onCancelAll(file.id, () => {\n      upload.abort();\n      this.resetUploaderReferences(file.id, {\n        abort: true\n      });\n      resolve(`upload ${file.id} was canceled`);\n    });\n    eventManager.onFilePause(file.id, isPaused => {\n      if (isPaused) {\n        upload.pause();\n      } else {\n        upload.start();\n      }\n    });\n    eventManager.onPauseAll(file.id, () => {\n      upload.pause();\n    });\n    eventManager.onResumeAll(file.id, () => {\n      upload.start();\n    });\n    upload.start();\n  });\n}\nfunction _getCompanionClientArgs2(file) {\n  var _file$remote;\n  return {\n    ...((_file$remote = file.remote) == null ? void 0 : _file$remote.body),\n    protocol: 's3-multipart',\n    size: file.data.size,\n    metadata: file.meta\n  };\n}\nAwsS3Multipart.VERSION = packageJson.version;\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/aws-s3/lib/index.js?");

/***/ }),

/***/ "./node_modules/@uppy/aws-s3/lib/utils.js":
/*!************************************************!*\
  !*** ./node_modules/@uppy/aws-s3/lib/utils.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   throwIfAborted: () => (/* binding */ throwIfAborted)\n/* harmony export */ });\n/* harmony import */ var _uppy_utils_lib_AbortController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uppy/utils/lib/AbortController */ \"./node_modules/@uppy/utils/lib/AbortController.js\");\n\nfunction throwIfAborted(signal) {\n  if (signal != null && signal.aborted) {\n    throw (0,_uppy_utils_lib_AbortController__WEBPACK_IMPORTED_MODULE_0__.createAbortError)('The operation was aborted', {\n      cause: signal.reason\n    });\n  }\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/aws-s3/lib/utils.js?");

/***/ }),

/***/ "./node_modules/@uppy/companion-client/lib/AuthError.js":
/*!**************************************************************!*\
  !*** ./node_modules/@uppy/companion-client/lib/AuthError.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n\nclass AuthError extends Error {\n  constructor() {\n    super('Authorization required');\n    this.name = 'AuthError';\n\n    // we use a property because of instanceof is unsafe:\n    // https://github.com/transloadit/uppy/pull/4619#discussion_r1406225982\n    this.isAuthError = true;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthError);\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/companion-client/lib/AuthError.js?");

/***/ }),

/***/ "./node_modules/@uppy/companion-client/lib/Provider.js":
/*!*************************************************************!*\
  !*** ./node_modules/@uppy/companion-client/lib/Provider.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _RequestClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RequestClient.js */ \"./node_modules/@uppy/companion-client/lib/RequestClient.js\");\n/* harmony import */ var _getAllowedHosts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getAllowedHosts.js */ \"./node_modules/@uppy/companion-client/lib/getAllowedHosts.js\");\nfunction _classPrivateFieldLooseBase(e, t) { if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\"); return e; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(e) { return \"__private_\" + id++ + \"_\" + e; }\n\n\nconst getName = id => {\n  return id.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(' ');\n};\nfunction getOrigin() {\n  // eslint-disable-next-line no-restricted-globals\n  return location.origin;\n}\nvar _refreshingTokenPromise = /*#__PURE__*/_classPrivateFieldLooseKey(\"refreshingTokenPromise\");\nvar _getAuthToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"getAuthToken\");\nvar _getPlugin = /*#__PURE__*/_classPrivateFieldLooseKey(\"getPlugin\");\nclass Provider extends _RequestClient_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(uppy, opts) {\n    super(uppy, opts);\n    Object.defineProperty(this, _getPlugin, {\n      value: _getPlugin2\n    });\n    Object.defineProperty(this, _getAuthToken, {\n      value: _getAuthToken2\n    });\n    Object.defineProperty(this, _refreshingTokenPromise, {\n      writable: true,\n      value: void 0\n    });\n    this.provider = opts.provider;\n    this.id = this.provider;\n    this.name = this.opts.name || getName(this.id);\n    this.pluginId = this.opts.pluginId;\n    this.tokenKey = `companion-${this.pluginId}-auth-token`;\n    this.companionKeysParams = this.opts.companionKeysParams;\n    this.preAuthToken = null;\n    this.supportsRefreshToken = !!opts.supportsRefreshToken;\n  }\n  async headers() {\n    const [headers, token] = await Promise.all([super.headers(), _classPrivateFieldLooseBase(this, _getAuthToken)[_getAuthToken]()]);\n    const authHeaders = {};\n    if (token) {\n      authHeaders['uppy-auth-token'] = token;\n    }\n    if (this.companionKeysParams) {\n      authHeaders['uppy-credentials-params'] = btoa(JSON.stringify({\n        params: this.companionKeysParams\n      }));\n    }\n    return {\n      ...headers,\n      ...authHeaders\n    };\n  }\n  onReceiveResponse(response) {\n    super.onReceiveResponse(response);\n    const plugin = _classPrivateFieldLooseBase(this, _getPlugin)[_getPlugin]();\n    const oldAuthenticated = plugin.getPluginState().authenticated;\n    const authenticated = oldAuthenticated ? response.status !== _RequestClient_js__WEBPACK_IMPORTED_MODULE_0__.authErrorStatusCode : response.status < 400;\n    plugin.setPluginState({\n      authenticated\n    });\n    return response;\n  }\n  async setAuthToken(token) {\n    return _classPrivateFieldLooseBase(this, _getPlugin)[_getPlugin]().storage.setItem(this.tokenKey, token);\n  }\n  async removeAuthToken() {\n    return _classPrivateFieldLooseBase(this, _getPlugin)[_getPlugin]().storage.removeItem(this.tokenKey);\n  }\n  /**\n   * Ensure we have a preauth token if necessary. Attempts to fetch one if we don't,\n   * or rejects if loading one fails.\n   */\n  async ensurePreAuth() {\n    if (this.companionKeysParams && !this.preAuthToken) {\n      await this.fetchPreAuthToken();\n      if (!this.preAuthToken) {\n        throw new Error('Could not load authentication data required for third-party login. Please try again later.');\n      }\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars\n  authQuery(data) {\n    return {};\n  }\n  authUrl(_ref) {\n    let {\n      authFormData,\n      query\n    } = _ref;\n    const params = new URLSearchParams({\n      ...query,\n      // This is only used for Companion instances configured to accept multiple origins.\n      state: btoa(JSON.stringify({\n        origin: getOrigin()\n      })),\n      ...this.authQuery({\n        authFormData\n      })\n    });\n    if (this.preAuthToken) {\n      params.set('uppyPreAuthToken', this.preAuthToken);\n    }\n    return `${this.hostname}/${this.id}/connect?${params}`;\n  }\n  async loginSimpleAuth(_ref2) {\n    let {\n      uppyVersions,\n      authFormData,\n      signal\n    } = _ref2;\n    const response = await this.post(`${this.id}/simple-auth`, {\n      form: authFormData\n    }, {\n      qs: {\n        uppyVersions\n      },\n      signal\n    });\n    this.setAuthToken(response.uppyAuthToken);\n  }\n  async loginOAuth(_ref3) {\n    let {\n      uppyVersions,\n      authFormData,\n      signal\n    } = _ref3;\n    await this.ensurePreAuth();\n    signal.throwIfAborted();\n    return new Promise((resolve, reject) => {\n      const link = this.authUrl({\n        query: {\n          uppyVersions\n        },\n        authFormData\n      });\n      const authWindow = window.open(link, '_blank');\n      let cleanup;\n      const handleToken = e => {\n        if (e.source !== authWindow) {\n          let jsonData = '';\n          try {\n            // TODO improve our uppy logger so that it can take an arbitrary number of arguments,\n            // each either objects, errors or strings,\n            // then we don’t have to manually do these things like json stringify when logging.\n            // the logger should never throw an error.\n            jsonData = JSON.stringify(e.data);\n          } catch (err) {\n            // in case JSON.stringify fails (ignored)\n          }\n          this.uppy.log(`ignoring event from unknown source ${jsonData}`, 'warning');\n          return;\n        }\n        const {\n          companionAllowedHosts\n        } = _classPrivateFieldLooseBase(this, _getPlugin)[_getPlugin]().opts;\n        if (!(0,_getAllowedHosts_js__WEBPACK_IMPORTED_MODULE_1__.isOriginAllowed)(e.origin, companionAllowedHosts)) {\n          reject(new Error(`rejecting event from ${e.origin} vs allowed pattern ${companionAllowedHosts}`));\n          return;\n        }\n\n        // Check if it's a string before doing the JSON.parse to maintain support\n        // for older Companion versions that used object references\n        const data = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;\n        if (data.error) {\n          const {\n            uppy\n          } = this;\n          const message = uppy.i18n('authAborted');\n          uppy.info({\n            message\n          }, 'warning', 5000);\n          reject(new Error('auth aborted'));\n          return;\n        }\n        if (!data.token) {\n          reject(new Error('did not receive token from auth window'));\n          return;\n        }\n        cleanup();\n        resolve(this.setAuthToken(data.token));\n      };\n      cleanup = () => {\n        authWindow == null || authWindow.close();\n        window.removeEventListener('message', handleToken);\n        signal.removeEventListener('abort', cleanup);\n      };\n      signal.addEventListener('abort', cleanup);\n      window.addEventListener('message', handleToken);\n    });\n  }\n  async login(_ref4) {\n    let {\n      uppyVersions,\n      authFormData,\n      signal\n    } = _ref4;\n    return this.loginOAuth({\n      uppyVersions,\n      authFormData,\n      signal\n    });\n  }\n  refreshTokenUrl() {\n    return `${this.hostname}/${this.id}/refresh-token`;\n  }\n  fileUrl(id) {\n    return `${this.hostname}/${this.id}/get/${id}`;\n  }\n  async request() {\n    await _classPrivateFieldLooseBase(this, _refreshingTokenPromise)[_refreshingTokenPromise];\n    try {\n      // to test simulate access token expired (leading to a token token refresh),\n      // see mockAccessTokenExpiredError in companion/drive.\n      // If you want to test refresh token *and* access token invalid, do this for example with Google Drive:\n      // While uploading, go to your google account settings,\n      // \"Third-party apps & services\", then click \"Companion\" and \"Remove access\".\n\n      return await super.request(...arguments);\n    } catch (err) {\n      if (!this.supportsRefreshToken) throw err;\n      // only handle auth errors (401 from provider), and only handle them if we have a (refresh) token\n      const authTokenAfter = await _classPrivateFieldLooseBase(this, _getAuthToken)[_getAuthToken]();\n      if (!err.isAuthError || !authTokenAfter) throw err;\n      if (_classPrivateFieldLooseBase(this, _refreshingTokenPromise)[_refreshingTokenPromise] == null) {\n        // Many provider requests may be starting at once, however refresh token should only be called once.\n        // Once a refresh token operation has started, we need all other request to wait for this operation (atomically)\n        _classPrivateFieldLooseBase(this, _refreshingTokenPromise)[_refreshingTokenPromise] = (async () => {\n          try {\n            this.uppy.log(`[CompanionClient] Refreshing expired auth token`);\n            const response = await super.request({\n              path: this.refreshTokenUrl(),\n              method: 'POST'\n            });\n            await this.setAuthToken(response.uppyAuthToken);\n          } catch (refreshTokenErr) {\n            if (refreshTokenErr.isAuthError) {\n              // if refresh-token has failed with auth error, delete token, so we don't keep trying to refresh in future\n              await this.removeAuthToken();\n            }\n            throw err;\n          } finally {\n            _classPrivateFieldLooseBase(this, _refreshingTokenPromise)[_refreshingTokenPromise] = undefined;\n          }\n        })();\n      }\n      await _classPrivateFieldLooseBase(this, _refreshingTokenPromise)[_refreshingTokenPromise];\n\n      // now retry the request with our new refresh token\n      return super.request(...arguments);\n    }\n  }\n  async fetchPreAuthToken() {\n    if (!this.companionKeysParams) {\n      return;\n    }\n    try {\n      const res = await this.post(`${this.id}/preauth/`, {\n        params: this.companionKeysParams\n      });\n      this.preAuthToken = res.token;\n    } catch (err) {\n      this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${err}`, 'warning');\n    }\n  }\n  list(directory, options) {\n    return this.get(`${this.id}/list/${directory || ''}`, options);\n  }\n  async logout(options) {\n    const response = await this.get(`${this.id}/logout`, options);\n    await this.removeAuthToken();\n    return response;\n  }\n}\nasync function _getAuthToken2() {\n  return _classPrivateFieldLooseBase(this, _getPlugin)[_getPlugin]().storage.getItem(this.tokenKey);\n}\nfunction _getPlugin2() {\n  const plugin = this.uppy.getPlugin(this.pluginId);\n  if (plugin == null) throw new Error('Plugin was nullish');\n  return plugin;\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/companion-client/lib/Provider.js?");

/***/ }),

/***/ "./node_modules/@uppy/companion-client/lib/RequestClient.js":
/*!******************************************************************!*\
  !*** ./node_modules/@uppy/companion-client/lib/RequestClient.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authErrorStatusCode: () => (/* binding */ authErrorStatusCode),\n/* harmony export */   \"default\": () => (/* binding */ RequestClient)\n/* harmony export */ });\n/* harmony import */ var _uppy_utils_lib_UserFacingApiError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uppy/utils/lib/UserFacingApiError */ \"./node_modules/@uppy/utils/lib/UserFacingApiError.js\");\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! p-retry */ \"./node_modules/p-retry/index.js\");\n/* harmony import */ var _uppy_utils_lib_fetchWithNetworkError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @uppy/utils/lib/fetchWithNetworkError */ \"./node_modules/@uppy/utils/lib/fetchWithNetworkError.js\");\n/* harmony import */ var _uppy_utils_lib_ErrorWithCause__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @uppy/utils/lib/ErrorWithCause */ \"./node_modules/@uppy/utils/lib/ErrorWithCause.js\");\n/* harmony import */ var _uppy_utils_lib_getSocketHost__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @uppy/utils/lib/getSocketHost */ \"./node_modules/@uppy/utils/lib/getSocketHost.js\");\n/* harmony import */ var _AuthError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AuthError.js */ \"./node_modules/@uppy/companion-client/lib/AuthError.js\");\nfunction _classPrivateFieldLooseBase(e, t) { if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\"); return e; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(e) { return \"__private_\" + id++ + \"_\" + e; }\n\n// eslint-disable-next-line import/no-extraneous-dependencies\n\n\n\n\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore We don't want TS to generate types for the package.json\nconst packageJson = {\n  \"version\": \"4.4.1\"\n};\n// Remove the trailing slash so we can always safely append /xyz.\nfunction stripSlash(url) {\n  return url.replace(/\\/$/, '');\n}\nconst retryCount = 10; // set to a low number, like 2 to test manual user retries\nconst socketActivityTimeoutMs = 5 * 60 * 1000; // set to a low number like 10000 to test this\n\nconst authErrorStatusCode = 401;\nclass HttpError extends Error {\n  constructor(_ref) {\n    let {\n      statusCode,\n      message\n    } = _ref;\n    super(message);\n    this.name = 'HttpError';\n    this.statusCode = statusCode;\n  }\n}\nasync function handleJSONResponse(res) {\n  if (res.status === authErrorStatusCode) {\n    throw new _AuthError_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\n  }\n  if (res.ok) {\n    return res.json();\n  }\n  let errMsg = `Failed request with status: ${res.status}. ${res.statusText}`;\n  let errData;\n  try {\n    errData = await res.json();\n    if (errData.message) errMsg = `${errMsg} message: ${errData.message}`;\n    if (errData.requestId) errMsg = `${errMsg} request-Id: ${errData.requestId}`;\n  } catch (cause) {\n    // if the response contains invalid JSON, let's ignore the error data\n    throw new Error(errMsg, {\n      cause\n    });\n  }\n  if (res.status >= 400 && res.status <= 499 && errData.message) {\n    throw new _uppy_utils_lib_UserFacingApiError__WEBPACK_IMPORTED_MODULE_0__[\"default\"](errData.message);\n  }\n  throw new HttpError({\n    statusCode: res.status,\n    message: errMsg\n  });\n}\nfunction emitSocketProgress(uploader, progressData, file) {\n  const {\n    progress,\n    bytesUploaded,\n    bytesTotal\n  } = progressData;\n  if (progress) {\n    var _file$progress$upload;\n    uploader.uppy.log(`Upload progress: ${progress}`);\n    uploader.uppy.emit('upload-progress', file, {\n      uploadStarted: (_file$progress$upload = file.progress.uploadStarted) != null ? _file$progress$upload : 0,\n      bytesUploaded,\n      bytesTotal\n    });\n  }\n}\nvar _companionHeaders = /*#__PURE__*/_classPrivateFieldLooseKey(\"companionHeaders\");\nvar _getUrl = /*#__PURE__*/_classPrivateFieldLooseKey(\"getUrl\");\nvar _requestSocketToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"requestSocketToken\");\nvar _awaitRemoteFileUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"awaitRemoteFileUpload\");\nclass RequestClient {\n  constructor(uppy, opts) {\n    /**\n     * This method will ensure a websocket for the specified file and returns a promise that resolves\n     * when the file has finished downloading, or rejects if it fails.\n     * It will retry if the websocket gets disconnected\n     */\n    Object.defineProperty(this, _awaitRemoteFileUpload, {\n      value: _awaitRemoteFileUpload2\n    });\n    Object.defineProperty(this, _getUrl, {\n      value: _getUrl2\n    });\n    Object.defineProperty(this, _companionHeaders, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _requestSocketToken, {\n      writable: true,\n      value: async _ref2 => {\n        var _file$remote;\n        let {\n          file,\n          postBody,\n          signal\n        } = _ref2;\n        if (((_file$remote = file.remote) == null ? void 0 : _file$remote.url) == null) {\n          throw new Error('Cannot connect to an undefined URL');\n        }\n        const res = await this.post(file.remote.url, {\n          ...file.remote.body,\n          ...postBody\n        }, {\n          signal\n        });\n        return res.token;\n      }\n    });\n    this.uppy = uppy;\n    this.opts = opts;\n    this.onReceiveResponse = this.onReceiveResponse.bind(this);\n    _classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders] = opts.companionHeaders;\n  }\n  setCompanionHeaders(headers) {\n    _classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders] = headers;\n  }\n  [Symbol.for('uppy test: getCompanionHeaders')]() {\n    return _classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders];\n  }\n  get hostname() {\n    const {\n      companion\n    } = this.uppy.getState();\n    const host = this.opts.companionUrl;\n    return stripSlash(companion && companion[host] ? companion[host] : host);\n  }\n  async headers(emptyBody) {\n    if (emptyBody === void 0) {\n      emptyBody = false;\n    }\n    const defaultHeaders = {\n      Accept: 'application/json',\n      ...(emptyBody ? undefined : {\n        // Passing those headers on requests with no data forces browsers to first make a preflight request.\n        'Content-Type': 'application/json'\n      })\n    };\n    return {\n      ...defaultHeaders,\n      ..._classPrivateFieldLooseBase(this, _companionHeaders)[_companionHeaders]\n    };\n  }\n  onReceiveResponse(res) {\n    const {\n      headers\n    } = res;\n    const state = this.uppy.getState();\n    const companion = state.companion || {};\n    const host = this.opts.companionUrl;\n\n    // Store the self-identified domain name for the Companion instance we just hit.\n    if (headers.has('i-am') && headers.get('i-am') !== companion[host]) {\n      this.uppy.setState({\n        companion: {\n          ...companion,\n          [host]: headers.get('i-am')\n        }\n      });\n    }\n  }\n  async request(_ref3) {\n    let {\n      path,\n      method = 'GET',\n      data,\n      skipPostResponse,\n      signal\n    } = _ref3;\n    try {\n      const headers = await this.headers(!data);\n      const response = await (0,_uppy_utils_lib_fetchWithNetworkError__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path), {\n        method,\n        signal,\n        headers,\n        credentials: this.opts.companionCookiesRule || 'same-origin',\n        body: data ? JSON.stringify(data) : null\n      });\n      if (!skipPostResponse) this.onReceiveResponse(response);\n      return await handleJSONResponse(response);\n    } catch (err) {\n      // pass these through\n      if (err.isAuthError || err.name === 'UserFacingApiError' || err.name === 'AbortError') throw err;\n      throw new _uppy_utils_lib_ErrorWithCause__WEBPACK_IMPORTED_MODULE_2__[\"default\"](`Could not ${method} ${_classPrivateFieldLooseBase(this, _getUrl)[_getUrl](path)}`, {\n        cause: err\n      });\n    }\n  }\n  async get(path, options) {\n    return this.request({\n      ...options,\n      path\n    });\n  }\n  async post(path, data, options) {\n    return this.request({\n      ...options,\n      path,\n      method: 'POST',\n      data\n    });\n  }\n  async delete(path, data, options) {\n    return this.request({\n      ...options,\n      path,\n      method: 'DELETE',\n      data\n    });\n  }\n\n  /**\n   * Remote uploading consists of two steps:\n   * 1. #requestSocketToken which starts the download/upload in companion and returns a unique token for the upload.\n   * Then companion will halt the upload until:\n   * 2. #awaitRemoteFileUpload is called, which will open/ensure a websocket connection towards companion, with the\n   * previously generated token provided. It returns a promise that will resolve/reject once the file has finished\n   * uploading or is otherwise done (failed, canceled)\n   */\n  async uploadRemoteFile(file, reqBody, options) {\n    var _this = this;\n    try {\n      const {\n        signal,\n        getQueue\n      } = options || {};\n      return await (0,p_retry__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(async () => {\n        var _this$uppy$getFile;\n        // if we already have a serverToken, assume that we are resuming the existing server upload id\n        const existingServerToken = (_this$uppy$getFile = this.uppy.getFile(file.id)) == null ? void 0 : _this$uppy$getFile.serverToken;\n        if (existingServerToken != null) {\n          this.uppy.log(`Connecting to exiting websocket ${existingServerToken}`);\n          return _classPrivateFieldLooseBase(this, _awaitRemoteFileUpload)[_awaitRemoteFileUpload]({\n            file,\n            queue: getQueue(),\n            signal\n          });\n        }\n        const queueRequestSocketToken = getQueue().wrapPromiseFunction(async function () {\n          try {\n            return await _classPrivateFieldLooseBase(_this, _requestSocketToken)[_requestSocketToken](...arguments);\n          } catch (outerErr) {\n            // throwing AbortError will cause p-retry to stop retrying\n            if (outerErr.isAuthError) throw new p_retry__WEBPACK_IMPORTED_MODULE_5__.AbortError(outerErr);\n            if (outerErr.cause == null) throw outerErr;\n            const err = outerErr.cause;\n            const isRetryableHttpError = () => [408, 409, 429, 418, 423].includes(err.statusCode) || err.statusCode >= 500 && err.statusCode <= 599 && ![501, 505].includes(err.statusCode);\n            if (err.name === 'HttpError' && !isRetryableHttpError()) throw new p_retry__WEBPACK_IMPORTED_MODULE_5__.AbortError(err);\n\n            // p-retry will retry most other errors,\n            // but it will not retry TypeError (except network error TypeErrors)\n            throw err;\n          }\n        }, {\n          priority: -1\n        });\n        const serverToken = await queueRequestSocketToken({\n          file,\n          postBody: reqBody,\n          signal\n        }).abortOn(signal);\n        if (!this.uppy.getFile(file.id)) return undefined; // has file since been removed?\n\n        this.uppy.setFileState(file.id, {\n          serverToken\n        });\n        return _classPrivateFieldLooseBase(this, _awaitRemoteFileUpload)[_awaitRemoteFileUpload]({\n          file: this.uppy.getFile(file.id),\n          // re-fetching file because it might have changed in the meantime\n          queue: getQueue(),\n          signal\n        });\n      }, {\n        retries: retryCount,\n        signal,\n        onFailedAttempt: err => this.uppy.log(`Retrying upload due to: ${err.message}`, 'warning')\n      });\n    } catch (err) {\n      // this is a bit confusing, but note that an error with the `name` prop set to 'AbortError' (from AbortController)\n      // is not the same as `p-retry` `AbortError`\n      if (err.name === 'AbortError') {\n        // The file upload was aborted, it’s not an error\n        return undefined;\n      }\n      this.uppy.emit('upload-error', file, err);\n      throw err;\n    }\n  }\n}\nfunction _getUrl2(url) {\n  if (/^(https?:|)\\/\\//.test(url)) {\n    return url;\n  }\n  return `${this.hostname}/${url}`;\n}\nasync function _awaitRemoteFileUpload2(_ref4) {\n  let {\n    file,\n    queue,\n    signal\n  } = _ref4;\n  let removeEventHandlers;\n  const {\n    capabilities\n  } = this.uppy.getState();\n  try {\n    return await new Promise((resolve, reject) => {\n      const token = file.serverToken;\n      const host = (0,_uppy_utils_lib_getSocketHost__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(file.remote.companionUrl);\n      let socket;\n      let socketAbortController;\n      let activityTimeout;\n      let {\n        isPaused\n      } = file;\n      const socketSend = (action, payload) => {\n        if (socket == null || socket.readyState !== socket.OPEN) {\n          var _socket;\n          this.uppy.log(`Cannot send \"${action}\" to socket ${file.id} because the socket state was ${String((_socket = socket) == null ? void 0 : _socket.readyState)}`, 'warning');\n          return;\n        }\n        socket.send(JSON.stringify({\n          action,\n          payload: payload != null ? payload : {}\n        }));\n      };\n      function sendState() {\n        if (!capabilities.resumableUploads) return;\n        if (isPaused) socketSend('pause');else socketSend('resume');\n      }\n      const createWebsocket = async () => {\n        if (socketAbortController) socketAbortController.abort();\n        socketAbortController = new AbortController();\n        const onFatalError = err => {\n          var _socketAbortControlle;\n          // Remove the serverToken so that a new one will be created for the retry.\n          this.uppy.setFileState(file.id, {\n            serverToken: null\n          });\n          (_socketAbortControlle = socketAbortController) == null || _socketAbortControlle.abort == null || _socketAbortControlle.abort();\n          reject(err);\n        };\n\n        // todo instead implement the ability for users to cancel / retry *currently uploading files* in the UI\n        function resetActivityTimeout() {\n          clearTimeout(activityTimeout);\n          if (isPaused) return;\n          activityTimeout = setTimeout(() => onFatalError(new Error('Timeout waiting for message from Companion socket')), socketActivityTimeoutMs);\n        }\n        try {\n          await queue.wrapPromiseFunction(async () => {\n            const reconnectWebsocket = async () =>\n            // eslint-disable-next-line promise/param-names\n            new Promise((_, rejectSocket) => {\n              socket = new WebSocket(`${host}/api/${token}`);\n              resetActivityTimeout();\n              socket.addEventListener('close', () => {\n                socket = undefined;\n                rejectSocket(new Error('Socket closed unexpectedly'));\n              });\n              socket.addEventListener('error', error => {\n                var _socket2;\n                this.uppy.log(`Companion socket error ${JSON.stringify(error)}, closing socket`, 'warning');\n                (_socket2 = socket) == null || _socket2.close(); // will 'close' event to be emitted\n              });\n              socket.addEventListener('open', () => {\n                sendState();\n              });\n              socket.addEventListener('message', e => {\n                resetActivityTimeout();\n                try {\n                  const {\n                    action,\n                    payload\n                  } = JSON.parse(e.data);\n                  switch (action) {\n                    case 'progress':\n                      {\n                        emitSocketProgress(this, payload, this.uppy.getFile(file.id));\n                        break;\n                      }\n                    case 'success':\n                      {\n                        var _payload$response, _payload$response$sta, _payload$response2, _socketAbortControlle2;\n                        // payload.response is sent from companion for xhr-upload (aka uploadMultipart in companion) and\n                        // s3 multipart (aka uploadS3Multipart)\n                        // but not for tus/transloadit (aka uploadTus)\n                        // responseText is a string which may or may not be in JSON format\n                        // this means that an upload destination of xhr or s3 multipart MUST respond with valid JSON\n                        // to companion, or the JSON.parse will crash\n                        const text = (_payload$response = payload.response) == null ? void 0 : _payload$response.responseText;\n                        this.uppy.emit('upload-success', this.uppy.getFile(file.id), {\n                          uploadURL: payload.url,\n                          status: (_payload$response$sta = (_payload$response2 = payload.response) == null ? void 0 : _payload$response2.status) != null ? _payload$response$sta : 200,\n                          body: text ? JSON.parse(text) : undefined\n                        });\n                        (_socketAbortControlle2 = socketAbortController) == null || _socketAbortControlle2.abort == null || _socketAbortControlle2.abort();\n                        resolve();\n                        break;\n                      }\n                    case 'error':\n                      {\n                        const {\n                          message\n                        } = payload.error;\n                        throw Object.assign(new Error(message), {\n                          cause: payload.error\n                        });\n                      }\n                    default:\n                      this.uppy.log(`Companion socket unknown action ${action}`, 'warning');\n                  }\n                } catch (err) {\n                  onFatalError(err);\n                }\n              });\n              const closeSocket = () => {\n                this.uppy.log(`Closing socket ${file.id}`);\n                clearTimeout(activityTimeout);\n                if (socket) socket.close();\n                socket = undefined;\n              };\n              socketAbortController.signal.addEventListener('abort', () => {\n                closeSocket();\n              });\n            });\n            await (0,p_retry__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(reconnectWebsocket, {\n              retries: retryCount,\n              signal: socketAbortController.signal,\n              onFailedAttempt: () => {\n                if (socketAbortController.signal.aborted) return; // don't log in this case\n                this.uppy.log(`Retrying websocket ${file.id}`);\n              }\n            });\n          })().abortOn(socketAbortController.signal);\n        } catch (err) {\n          if (socketAbortController.signal.aborted) return;\n          onFatalError(err);\n        }\n      };\n      const pause = newPausedState => {\n        if (!capabilities.resumableUploads) return;\n        isPaused = newPausedState;\n        if (socket) sendState();\n      };\n      const onFileRemove = targetFile => {\n        var _socketAbortControlle3;\n        if (!capabilities.individualCancellation) return;\n        if (targetFile.id !== file.id) return;\n        socketSend('cancel');\n        (_socketAbortControlle3 = socketAbortController) == null || _socketAbortControlle3.abort == null || _socketAbortControlle3.abort();\n        this.uppy.log(`upload ${file.id} was removed`);\n        resolve();\n      };\n      const onCancelAll = () => {\n        var _socketAbortControlle4;\n        socketSend('cancel');\n        (_socketAbortControlle4 = socketAbortController) == null || _socketAbortControlle4.abort == null || _socketAbortControlle4.abort();\n        this.uppy.log(`upload ${file.id} was canceled`);\n        resolve();\n      };\n      const onFilePausedChange = (targetFile, newPausedState) => {\n        if ((targetFile == null ? void 0 : targetFile.id) !== file.id) return;\n        pause(newPausedState);\n      };\n      const onPauseAll = () => pause(true);\n      const onResumeAll = () => pause(false);\n      this.uppy.on('file-removed', onFileRemove);\n      this.uppy.on('cancel-all', onCancelAll);\n      this.uppy.on('upload-pause', onFilePausedChange);\n      this.uppy.on('pause-all', onPauseAll);\n      this.uppy.on('resume-all', onResumeAll);\n      removeEventHandlers = () => {\n        this.uppy.off('file-removed', onFileRemove);\n        this.uppy.off('cancel-all', onCancelAll);\n        this.uppy.off('upload-pause', onFilePausedChange);\n        this.uppy.off('pause-all', onPauseAll);\n        this.uppy.off('resume-all', onResumeAll);\n      };\n      signal.addEventListener('abort', () => {\n        var _socketAbortControlle5;\n        (_socketAbortControlle5 = socketAbortController) == null || _socketAbortControlle5.abort();\n      });\n      createWebsocket();\n    });\n  } finally {\n    // @ts-expect-error used before defined\n    removeEventHandlers == null || removeEventHandlers();\n  }\n}\nRequestClient.VERSION = packageJson.version;\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/companion-client/lib/RequestClient.js?");

/***/ }),

/***/ "./node_modules/@uppy/companion-client/lib/SearchProvider.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@uppy/companion-client/lib/SearchProvider.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SearchProvider)\n/* harmony export */ });\n/* harmony import */ var _RequestClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RequestClient.js */ \"./node_modules/@uppy/companion-client/lib/RequestClient.js\");\n\nconst getName = id => {\n  return id.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(' ');\n};\nclass SearchProvider extends _RequestClient_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(uppy, opts) {\n    super(uppy, opts);\n    this.provider = opts.provider;\n    this.id = this.provider;\n    this.name = this.opts.name || getName(this.id);\n    this.pluginId = this.opts.pluginId;\n  }\n  fileUrl(id) {\n    return `${this.hostname}/search/${this.id}/get/${id}`;\n  }\n  search(text, queries) {\n    return this.get(`search/${this.id}/list?q=${encodeURIComponent(text)}${queries ? `&${queries}` : ''}`);\n  }\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/companion-client/lib/SearchProvider.js?");

/***/ }),

/***/ "./node_modules/@uppy/companion-client/lib/getAllowedHosts.js":
/*!********************************************************************!*\
  !*** ./node_modules/@uppy/companion-client/lib/getAllowedHosts.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getAllowedHosts),\n/* harmony export */   isOriginAllowed: () => (/* binding */ isOriginAllowed)\n/* harmony export */ });\n// https://stackoverflow.com/a/3561711/6519037\nfunction escapeRegex(string) {\n  return string.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nfunction wrapInRegex(value) {\n  if (typeof value === 'string') {\n    // TODO in the next major we should change this to `new RegExp(value)` so that the user can control start/end characters\n    return new RegExp(`^${value}$`); // throws if invalid regex\n  }\n  if (value instanceof RegExp) {\n    return value;\n  }\n  return undefined;\n}\nfunction getAllowedHosts(companionAllowedHosts, companionUrl) {\n  if (companionAllowedHosts) {\n    const validate = value => {\n      if (!(typeof value === 'string' && wrapInRegex(value)) &&\n      // wrapInRegex throws if invalid regex\n      !(value instanceof RegExp)) {\n        throw new TypeError(`The option \"companionAllowedHosts\" must be one of string, Array, RegExp`);\n      }\n    };\n    if (Array.isArray(companionAllowedHosts)) {\n      companionAllowedHosts.every(validate);\n    } else {\n      validate(companionAllowedHosts);\n    }\n    return companionAllowedHosts;\n  }\n\n  // if it does not start with https://, prefix it (and remove any leading slashes)\n  let ret = companionUrl;\n  if (/^(?!https?:\\/\\/).*$/i.test(ret)) {\n    ret = `https://${companionUrl.replace(/^\\/\\//, '')}`;\n  }\n  ret = new URL(ret).origin;\n  ret = escapeRegex(ret);\n  return ret;\n}\nfunction isOriginAllowed(origin, allowedOrigin) {\n  const patterns = Array.isArray(allowedOrigin) ? allowedOrigin.map(wrapInRegex) : [wrapInRegex(allowedOrigin)];\n  return patterns.some(pattern => (pattern == null ? void 0 : pattern.test(origin)) || (pattern == null ? void 0 : pattern.test(`${origin}/`))); // allowing for trailing '/'\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/companion-client/lib/getAllowedHosts.js?");

/***/ }),

/***/ "./node_modules/@uppy/companion-client/lib/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uppy/companion-client/lib/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* reexport safe */ _Provider_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   RequestClient: () => (/* reexport safe */ _RequestClient_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   SearchProvider: () => (/* reexport safe */ _SearchProvider_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   getAllowedHosts: () => (/* reexport safe */ _getAllowedHosts_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   tokenStorage: () => (/* reexport module object */ _tokenStorage_js__WEBPACK_IMPORTED_MODULE_4__)\n/* harmony export */ });\n/* harmony import */ var _RequestClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RequestClient.js */ \"./node_modules/@uppy/companion-client/lib/RequestClient.js\");\n/* harmony import */ var _Provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Provider.js */ \"./node_modules/@uppy/companion-client/lib/Provider.js\");\n/* harmony import */ var _SearchProvider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SearchProvider.js */ \"./node_modules/@uppy/companion-client/lib/SearchProvider.js\");\n/* harmony import */ var _getAllowedHosts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getAllowedHosts.js */ \"./node_modules/@uppy/companion-client/lib/getAllowedHosts.js\");\n/* harmony import */ var _tokenStorage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tokenStorage.js */ \"./node_modules/@uppy/companion-client/lib/tokenStorage.js\");\n/**\n * Manages communications with Companion\n */\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/companion-client/lib/index.js?");

/***/ }),

/***/ "./node_modules/@uppy/companion-client/lib/tokenStorage.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@uppy/companion-client/lib/tokenStorage.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getItem: () => (/* binding */ getItem),\n/* harmony export */   removeItem: () => (/* binding */ removeItem),\n/* harmony export */   setItem: () => (/* binding */ setItem)\n/* harmony export */ });\n/**\n * This module serves as an Async wrapper for LocalStorage\n * Why? Because the Provider API `storage` option allows an async storage\n */\nasync function setItem(key, value) {\n  localStorage.setItem(key, value);\n}\nasync function getItem(key) {\n  return localStorage.getItem(key);\n}\nasync function removeItem(key) {\n  localStorage.removeItem(key);\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/companion-client/lib/tokenStorage.js?");

/***/ }),

/***/ "./node_modules/@uppy/core/lib/BasePlugin.js":
/*!***************************************************!*\
  !*** ./node_modules/@uppy/core/lib/BasePlugin.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BasePlugin)\n/* harmony export */ });\n/* harmony import */ var _uppy_utils_lib_Translator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uppy/utils/lib/Translator */ \"./node_modules/@uppy/utils/lib/Translator.js\");\n/* eslint-disable class-methods-use-this */\n\n/**\n * Core plugin logic that all plugins share.\n *\n * BasePlugin does not contain DOM rendering so it can be used for plugins\n * without a user interface.\n *\n * See `Plugin` for the extended version with Preact rendering for interfaces.\n */\n\n\n\n/**\n * DefinePluginOpts marks all of the passed AlwaysDefinedKeys as “required” or “always defined”.\n */\n\nclass BasePlugin {\n  constructor(uppy, opts) {\n    this.uppy = uppy;\n    this.opts = opts != null ? opts : {};\n  }\n  getPluginState() {\n    const {\n      plugins\n    } = this.uppy.getState();\n    return (plugins == null ? void 0 : plugins[this.id]) || {};\n  }\n  setPluginState(update) {\n    const {\n      plugins\n    } = this.uppy.getState();\n    this.uppy.setState({\n      plugins: {\n        ...plugins,\n        [this.id]: {\n          ...plugins[this.id],\n          ...update\n        }\n      }\n    });\n  }\n  setOptions(newOpts) {\n    this.opts = {\n      ...this.opts,\n      ...newOpts\n    };\n    this.setPluginState(undefined); // so that UI re-renders with new options\n    this.i18nInit();\n  }\n  i18nInit() {\n    const translator = new _uppy_utils_lib_Translator__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([this.defaultLocale, this.uppy.locale, this.opts.locale]);\n    this.i18n = translator.translate.bind(translator);\n    this.i18nArray = translator.translateArray.bind(translator);\n    this.setPluginState(undefined); // so that UI re-renders and we see the updated locale\n  }\n\n  /**\n   * Extendable methods\n   * ==================\n   * These methods are here to serve as an overview of the extendable methods as well as\n   * making them not conditional in use, such as `if (this.afterUpdate)`.\n   */\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  addTarget(plugin) {\n    throw new Error(\"Extend the addTarget method to add your plugin to another plugin's target\");\n  }\n  install() {}\n  uninstall() {}\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  update(state) {}\n\n  // Called after every state update, after everything's mounted. Debounced.\n  afterUpdate() {}\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/core/lib/BasePlugin.js?");

/***/ }),

/***/ "./node_modules/@uppy/core/lib/EventManager.js":
/*!*****************************************************!*\
  !*** ./node_modules/@uppy/core/lib/EventManager.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EventManager)\n/* harmony export */ });\nfunction _classPrivateFieldLooseBase(e, t) { if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\"); return e; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(e) { return \"__private_\" + id++ + \"_\" + e; }\nvar _uppy = /*#__PURE__*/_classPrivateFieldLooseKey(\"uppy\");\nvar _events = /*#__PURE__*/_classPrivateFieldLooseKey(\"events\");\n/**\n * Create a wrapper around an event emitter with a `remove` method to remove\n * all events that were added using the wrapped emitter.\n */\nclass EventManager {\n  constructor(uppy) {\n    Object.defineProperty(this, _uppy, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _events, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldLooseBase(this, _uppy)[_uppy] = uppy;\n  }\n  on(event, fn) {\n    _classPrivateFieldLooseBase(this, _events)[_events].push([event, fn]);\n    return _classPrivateFieldLooseBase(this, _uppy)[_uppy].on(event, fn);\n  }\n  remove() {\n    for (const [event, fn] of _classPrivateFieldLooseBase(this, _events)[_events].splice(0)) {\n      _classPrivateFieldLooseBase(this, _uppy)[_uppy].off(event, fn);\n    }\n  }\n  onFilePause(fileID, cb) {\n    this.on('upload-pause', (file, isPaused) => {\n      if (fileID === (file == null ? void 0 : file.id)) {\n        cb(isPaused);\n      }\n    });\n  }\n  onFileRemove(fileID, cb) {\n    this.on('file-removed', file => {\n      if (fileID === file.id) cb(file.id);\n    });\n  }\n  onPause(fileID, cb) {\n    this.on('upload-pause', (file, isPaused) => {\n      if (fileID === (file == null ? void 0 : file.id)) {\n        // const isPaused = this.#uppy.pauseResume(fileID)\n        cb(isPaused);\n      }\n    });\n  }\n  onRetry(fileID, cb) {\n    this.on('upload-retry', file => {\n      if (fileID === (file == null ? void 0 : file.id)) {\n        cb();\n      }\n    });\n  }\n  onRetryAll(fileID, cb) {\n    this.on('retry-all', () => {\n      if (!_classPrivateFieldLooseBase(this, _uppy)[_uppy].getFile(fileID)) return;\n      cb();\n    });\n  }\n  onPauseAll(fileID, cb) {\n    this.on('pause-all', () => {\n      if (!_classPrivateFieldLooseBase(this, _uppy)[_uppy].getFile(fileID)) return;\n      cb();\n    });\n  }\n  onCancelAll(fileID, eventHandler) {\n    var _this = this;\n    this.on('cancel-all', function () {\n      if (!_classPrivateFieldLooseBase(_this, _uppy)[_uppy].getFile(fileID)) return;\n      eventHandler(...arguments);\n    });\n  }\n  onResumeAll(fileID, cb) {\n    this.on('resume-all', () => {\n      if (!_classPrivateFieldLooseBase(this, _uppy)[_uppy].getFile(fileID)) return;\n      cb();\n    });\n  }\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/core/lib/EventManager.js?");

/***/ }),

/***/ "./node_modules/@uppy/core/lib/Restricter.js":
/*!***************************************************!*\
  !*** ./node_modules/@uppy/core/lib/Restricter.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Restricter: () => (/* binding */ Restricter),\n/* harmony export */   RestrictionError: () => (/* binding */ RestrictionError),\n/* harmony export */   defaultOptions: () => (/* binding */ defaultOptions)\n/* harmony export */ });\n/* harmony import */ var _transloadit_prettier_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @transloadit/prettier-bytes */ \"./node_modules/@transloadit/prettier-bytes/dist/prettierBytes.js\");\n/* harmony import */ var mime_match__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mime-match */ \"./node_modules/mime-match/index.js\");\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable max-classes-per-file, class-methods-use-this */\n\n// @ts-ignore untyped\n\n\n/**\n * The minimal required properties to be present from UppyFile in order to validate it.\n */\n\nconst defaultOptions = {\n  maxFileSize: null,\n  minFileSize: null,\n  maxTotalFileSize: null,\n  maxNumberOfFiles: null,\n  minNumberOfFiles: null,\n  allowedFileTypes: null,\n  requiredMetaFields: []\n};\nclass RestrictionError extends Error {\n  constructor(message, opts) {\n    var _opts$isUserFacing;\n    super(message);\n    this.isRestriction = true;\n    this.isUserFacing = (_opts$isUserFacing = opts == null ? void 0 : opts.isUserFacing) != null ? _opts$isUserFacing : true;\n    if (opts != null && opts.file) {\n      this.file = opts.file; // only some restriction errors are related to a particular file\n    }\n  }\n}\nclass Restricter {\n  constructor(getOpts, getI18n) {\n    this.getI18n = getI18n;\n    this.getOpts = () => {\n      var _opts$restrictions;\n      const opts = getOpts();\n      if (((_opts$restrictions = opts.restrictions) == null ? void 0 : _opts$restrictions.allowedFileTypes) != null && !Array.isArray(opts.restrictions.allowedFileTypes)) {\n        throw new TypeError('`restrictions.allowedFileTypes` must be an array');\n      }\n      return opts;\n    };\n  }\n\n  // Because these operations are slow, we cannot run them for every file (if we are adding multiple files)\n  validateAggregateRestrictions(existingFiles, addingFiles) {\n    const {\n      maxTotalFileSize,\n      maxNumberOfFiles\n    } = this.getOpts().restrictions;\n    if (maxNumberOfFiles) {\n      const nonGhostFiles = existingFiles.filter(f => !f.isGhost);\n      if (nonGhostFiles.length + addingFiles.length > maxNumberOfFiles) {\n        throw new RestrictionError(`${this.getI18n()('youCanOnlyUploadX', {\n          smart_count: maxNumberOfFiles\n        })}`);\n      }\n    }\n    if (maxTotalFileSize) {\n      const totalFilesSize = [...existingFiles, ...addingFiles].reduce((total, f) => {\n        var _f$size;\n        return total + ((_f$size = f.size) != null ? _f$size : 0);\n      }, 0);\n      if (totalFilesSize > maxTotalFileSize) {\n        throw new RestrictionError(this.getI18n()('aggregateExceedsSize', {\n          sizeAllowed: _transloadit_prettier_bytes__WEBPACK_IMPORTED_MODULE_0__(maxTotalFileSize),\n          size: _transloadit_prettier_bytes__WEBPACK_IMPORTED_MODULE_0__(totalFilesSize)\n        }));\n      }\n    }\n  }\n  validateSingleFile(file) {\n    const {\n      maxFileSize,\n      minFileSize,\n      allowedFileTypes\n    } = this.getOpts().restrictions;\n    if (allowedFileTypes) {\n      const isCorrectFileType = allowedFileTypes.some(type => {\n        // check if this is a mime-type\n        if (type.includes('/')) {\n          if (!file.type) return false;\n          return mime_match__WEBPACK_IMPORTED_MODULE_1__(file.type.replace(/;.*?$/, ''), type);\n        }\n\n        // otherwise this is likely an extension\n        if (type[0] === '.' && file.extension) {\n          return file.extension.toLowerCase() === type.slice(1).toLowerCase();\n        }\n        return false;\n      });\n      if (!isCorrectFileType) {\n        const allowedFileTypesString = allowedFileTypes.join(', ');\n        throw new RestrictionError(this.getI18n()('youCanOnlyUploadFileTypes', {\n          types: allowedFileTypesString\n        }), {\n          file\n        });\n      }\n    }\n\n    // We can't check maxFileSize if the size is unknown.\n    if (maxFileSize && file.size != null && file.size > maxFileSize) {\n      var _file$name;\n      throw new RestrictionError(this.getI18n()('exceedsSize', {\n        size: _transloadit_prettier_bytes__WEBPACK_IMPORTED_MODULE_0__(maxFileSize),\n        file: (_file$name = file.name) != null ? _file$name : this.getI18n()('unnamed')\n      }), {\n        file\n      });\n    }\n\n    // We can't check minFileSize if the size is unknown.\n    if (minFileSize && file.size != null && file.size < minFileSize) {\n      throw new RestrictionError(this.getI18n()('inferiorSize', {\n        size: _transloadit_prettier_bytes__WEBPACK_IMPORTED_MODULE_0__(minFileSize)\n      }), {\n        file\n      });\n    }\n  }\n  validate(existingFiles, addingFiles) {\n    addingFiles.forEach(addingFile => {\n      this.validateSingleFile(addingFile);\n    });\n    this.validateAggregateRestrictions(existingFiles, addingFiles);\n  }\n  validateMinNumberOfFiles(files) {\n    const {\n      minNumberOfFiles\n    } = this.getOpts().restrictions;\n    if (minNumberOfFiles && Object.keys(files).length < minNumberOfFiles) {\n      throw new RestrictionError(this.getI18n()('youHaveToAtLeastSelectX', {\n        smart_count: minNumberOfFiles\n      }));\n    }\n  }\n  getMissingRequiredMetaFields(file) {\n    var _file$name2;\n    const error = new RestrictionError(this.getI18n()('missingRequiredMetaFieldOnFile', {\n      fileName: (_file$name2 = file.name) != null ? _file$name2 : this.getI18n()('unnamed')\n    }));\n    const {\n      requiredMetaFields\n    } = this.getOpts().restrictions;\n    const missingFields = [];\n    for (const field of requiredMetaFields) {\n      if (!Object.hasOwn(file.meta, field) || file.meta[field] === '') {\n        missingFields.push(field);\n      }\n    }\n    return {\n      missingFields,\n      error\n    };\n  }\n}\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/core/lib/Restricter.js?");

/***/ }),

/***/ "./node_modules/@uppy/core/lib/Uppy.js":
/*!*********************************************!*\
  !*** ./node_modules/@uppy/core/lib/Uppy.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Uppy: () => (/* binding */ Uppy),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _uppy_utils_lib_Translator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uppy/utils/lib/Translator */ \"./node_modules/@uppy/utils/lib/Translator.js\");\n/* harmony import */ var namespace_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! namespace-emitter */ \"./node_modules/namespace-emitter/index.js\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! nanoid/non-secure */ \"./node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var lodash_throttle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/throttle.js */ \"./node_modules/lodash/throttle.js\");\n/* harmony import */ var _uppy_store_default__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @uppy/store-default */ \"./node_modules/@uppy/store-default/lib/index.js\");\n/* harmony import */ var _uppy_utils_lib_getFileType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @uppy/utils/lib/getFileType */ \"./node_modules/@uppy/utils/lib/getFileType.js\");\n/* harmony import */ var _uppy_utils_lib_getFileNameAndExtension__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @uppy/utils/lib/getFileNameAndExtension */ \"./node_modules/@uppy/utils/lib/getFileNameAndExtension.js\");\n/* harmony import */ var _uppy_utils_lib_generateFileID__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @uppy/utils/lib/generateFileID */ \"./node_modules/@uppy/utils/lib/generateFileID.js\");\n/* harmony import */ var _supportsUploadProgress_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./supportsUploadProgress.js */ \"./node_modules/@uppy/core/lib/supportsUploadProgress.js\");\n/* harmony import */ var _getFileName_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./getFileName.js */ \"./node_modules/@uppy/core/lib/getFileName.js\");\n/* harmony import */ var _loggers_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./loggers.js */ \"./node_modules/@uppy/core/lib/loggers.js\");\n/* harmony import */ var _Restricter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Restricter.js */ \"./node_modules/@uppy/core/lib/Restricter.js\");\n/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./locale.js */ \"./node_modules/@uppy/core/lib/locale.js\");\nfunction _classPrivateFieldLooseBase(e, t) { if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\"); return e; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(e) { return \"__private_\" + id++ + \"_\" + e; }\n/* eslint-disable max-classes-per-file */\n/* global AggregateError */\n\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore untyped\n\n\n\n\n\n\n\n\n\n\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore We don't want TS to generate types for the package.json\nconst packageJson = {\n  \"version\": \"4.4.1\"\n};\n\n\n/**\n * ids are always `string`s, except the root folder's id can be `null`\n */\n\n/**\n * PartialTree has the following structure.\n *\n *           FolderRoot\n *         ┌─────┴─────┐\n *     FolderNode     File\n *   ┌─────┴────┐\n *  File      File\n *\n * Root folder is called `PartialTreeFolderRoot`,\n * all other folders are called `PartialTreeFolderNode`, because they are \"internal nodes\".\n *\n * It's possible for `PartialTreeFolderNode` to be a leaf node if it doesn't contain any files.\n */\n\n/**\n * This is a base for a provider that does not necessarily use the Companion-assisted OAuth2 flow\n */\n\n/*\n * UnknownProviderPlugin can be any Companion plugin (such as Google Drive)\n * that uses the Companion-assisted OAuth flow.\n * As the plugins are passed around throughout Uppy we need a generic type for this.\n * It may seems like duplication, but this type safe. Changing the type of `storage`\n * will error in the `Provider` class of @uppy/companion-client and vice versa.\n *\n * Note that this is the *plugin* class, not a version of the `Provider` class.\n * `Provider` does operate on Companion plugins with `uppy.getPlugin()`.\n */\n\n/*\n * UnknownSearchProviderPlugin can be any search Companion plugin (such as Unsplash).\n * As the plugins are passed around throughout Uppy we need a generic type for this.\n * It may seems like duplication, but this type safe. Changing the type of `title`\n * will error in the `SearchProvider` class of @uppy/companion-client and vice versa.\n *\n * Note that this is the *plugin* class, not a version of the `SearchProvider` class.\n * `SearchProvider` does operate on Companion plugins with `uppy.getPlugin()`.\n */\n\n// TODO: can we use namespaces in other plugins to populate this?\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\n\n// The user facing type for UppyOptions used in uppy.setOptions()\n\n/** `OmitFirstArg<typeof someArray>` is the type of the returned value of `someArray.slice(1)`. */\n\nconst defaultUploadState = {\n  totalProgress: 0,\n  allowNewUpload: true,\n  error: null,\n  recoveredState: null\n};\n\n/**\n * Uppy Core module.\n * Manages plugins, state updates, acts as an event bus,\n * adds/removes files and metadata.\n */\nvar _plugins = /*#__PURE__*/_classPrivateFieldLooseKey(\"plugins\");\nvar _restricter = /*#__PURE__*/_classPrivateFieldLooseKey(\"restricter\");\nvar _storeUnsubscribe = /*#__PURE__*/_classPrivateFieldLooseKey(\"storeUnsubscribe\");\nvar _emitter = /*#__PURE__*/_classPrivateFieldLooseKey(\"emitter\");\nvar _preProcessors = /*#__PURE__*/_classPrivateFieldLooseKey(\"preProcessors\");\nvar _uploaders = /*#__PURE__*/_classPrivateFieldLooseKey(\"uploaders\");\nvar _postProcessors = /*#__PURE__*/_classPrivateFieldLooseKey(\"postProcessors\");\nvar _informAndEmit = /*#__PURE__*/_classPrivateFieldLooseKey(\"informAndEmit\");\nvar _checkRequiredMetaFieldsOnFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"checkRequiredMetaFieldsOnFile\");\nvar _checkRequiredMetaFields = /*#__PURE__*/_classPrivateFieldLooseKey(\"checkRequiredMetaFields\");\nvar _assertNewUploadAllowed = /*#__PURE__*/_classPrivateFieldLooseKey(\"assertNewUploadAllowed\");\nvar _transformFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"transformFile\");\nvar _startIfAutoProceed = /*#__PURE__*/_classPrivateFieldLooseKey(\"startIfAutoProceed\");\nvar _checkAndUpdateFileState = /*#__PURE__*/_classPrivateFieldLooseKey(\"checkAndUpdateFileState\");\nvar _handleUploadProgress = /*#__PURE__*/_classPrivateFieldLooseKey(\"handleUploadProgress\");\nvar _updateTotalProgress = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateTotalProgress\");\nvar _updateTotalProgressThrottled = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateTotalProgressThrottled\");\nvar _calculateTotalProgress = /*#__PURE__*/_classPrivateFieldLooseKey(\"calculateTotalProgress\");\nvar _addListeners = /*#__PURE__*/_classPrivateFieldLooseKey(\"addListeners\");\nvar _updateOnlineStatus = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateOnlineStatus\");\nvar _requestClientById = /*#__PURE__*/_classPrivateFieldLooseKey(\"requestClientById\");\nvar _createUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"createUpload\");\nvar _getUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"getUpload\");\nvar _removeUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"removeUpload\");\nvar _runUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"runUpload\");\nclass Uppy {\n  /**\n   * Instantiate Uppy\n   */\n  constructor(_opts) {\n    /**\n     * Run an upload. This picks up where it left off in case the upload is being restored.\n     */\n    Object.defineProperty(this, _runUpload, {\n      value: _runUpload2\n    });\n    /**\n     * Remove an upload, eg. if it has been canceled or completed.\n     *\n     */\n    Object.defineProperty(this, _removeUpload, {\n      value: _removeUpload2\n    });\n    Object.defineProperty(this, _getUpload, {\n      value: _getUpload2\n    });\n    /**\n     * Create an upload for a bunch of files.\n     *\n     */\n    Object.defineProperty(this, _createUpload, {\n      value: _createUpload2\n    });\n    /**\n     * Registers listeners for all global actions, like:\n     * `error`, `file-removed`, `upload-progress`\n     */\n    Object.defineProperty(this, _addListeners, {\n      value: _addListeners2\n    });\n    Object.defineProperty(this, _calculateTotalProgress, {\n      value: _calculateTotalProgress2\n    });\n    Object.defineProperty(this, _updateTotalProgress, {\n      value: _updateTotalProgress2\n    });\n    Object.defineProperty(this, _checkAndUpdateFileState, {\n      value: _checkAndUpdateFileState2\n    });\n    // Schedule an upload if `autoProceed` is enabled.\n    Object.defineProperty(this, _startIfAutoProceed, {\n      value: _startIfAutoProceed2\n    });\n    /**\n     * Create a file state object based on user-provided `addFile()` options.\n     */\n    Object.defineProperty(this, _transformFile, {\n      value: _transformFile2\n    });\n    Object.defineProperty(this, _assertNewUploadAllowed, {\n      value: _assertNewUploadAllowed2\n    });\n    Object.defineProperty(this, _checkRequiredMetaFields, {\n      value: _checkRequiredMetaFields2\n    });\n    Object.defineProperty(this, _checkRequiredMetaFieldsOnFile, {\n      value: _checkRequiredMetaFieldsOnFile2\n    });\n    Object.defineProperty(this, _informAndEmit, {\n      value: _informAndEmit2\n    });\n    Object.defineProperty(this, _plugins, {\n      writable: true,\n      value: Object.create(null)\n    });\n    Object.defineProperty(this, _restricter, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _storeUnsubscribe, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _emitter, {\n      writable: true,\n      value: namespace_emitter__WEBPACK_IMPORTED_MODULE_1__()\n    });\n    Object.defineProperty(this, _preProcessors, {\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, _uploaders, {\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, _postProcessors, {\n      writable: true,\n      value: new Set()\n    });\n    this.scheduledAutoProceed = null;\n    this.wasOffline = false;\n    Object.defineProperty(this, _handleUploadProgress, {\n      writable: true,\n      value: (file, progress) => {\n        const fileInState = file ? this.getFile(file.id) : undefined;\n        if (file == null || !fileInState) {\n          this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n          return;\n        }\n        if (fileInState.progress.percentage === 100) {\n          this.log(`Not setting progress for a file that has been already uploaded: ${file.id}`);\n          return;\n        }\n        const newProgress = {\n          bytesTotal: progress.bytesTotal,\n          // bytesTotal may be null or zero; in that case we can't divide by it\n          percentage: progress.bytesTotal != null && Number.isFinite(progress.bytesTotal) && progress.bytesTotal > 0 ? Math.round(progress.bytesUploaded / progress.bytesTotal * 100) : undefined\n        };\n        if (fileInState.progress.uploadStarted != null) {\n          this.setFileState(file.id, {\n            progress: {\n              ...fileInState.progress,\n              ...newProgress,\n              bytesUploaded: progress.bytesUploaded\n            }\n          });\n        } else {\n          this.setFileState(file.id, {\n            progress: {\n              ...fileInState.progress,\n              ...newProgress\n            }\n          });\n        }\n        _classPrivateFieldLooseBase(this, _updateTotalProgressThrottled)[_updateTotalProgressThrottled]();\n      }\n    });\n    // ___Why throttle at 500ms?\n    //    - We must throttle at >250ms for superfocus in Dashboard to work well\n    //    (because animation takes 0.25s, and we want to wait for all animations to be over before refocusing).\n    //    [Practical Check]: if thottle is at 100ms, then if you are uploading a file,\n    //    and click 'ADD MORE FILES', - focus won't activate in Firefox.\n    //    - We must throttle at around >500ms to avoid performance lags.\n    //    [Practical Check] Firefox, try to upload a big file for a prolonged period of time. Laptop will start to heat up.\n    Object.defineProperty(this, _updateTotalProgressThrottled, {\n      writable: true,\n      value: lodash_throttle_js__WEBPACK_IMPORTED_MODULE_2__(() => _classPrivateFieldLooseBase(this, _updateTotalProgress)[_updateTotalProgress](), 500, {\n        leading: true,\n        trailing: true\n      })\n    });\n    Object.defineProperty(this, _updateOnlineStatus, {\n      writable: true,\n      value: this.updateOnlineStatus.bind(this)\n    });\n    // We need to store request clients by a unique ID, so we can share RequestClient instances across files\n    // this allows us to do rate limiting and synchronous operations like refreshing provider tokens\n    // example: refreshing tokens: if each file has their own requestclient,\n    // we don't have any way to synchronize all requests in order to\n    // - block all requests\n    // - refresh the token\n    // - unblock all requests and allow them to run with a the new access token\n    // back when we had a requestclient per file, once an access token expired,\n    // all 6 files would go ahead and refresh the token at the same time\n    // (calling /refresh-token up to 6 times), which will probably fail for some providers\n    Object.defineProperty(this, _requestClientById, {\n      writable: true,\n      value: new Map()\n    });\n    this.defaultLocale = _locale_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\n    const defaultOptions = {\n      id: 'uppy',\n      autoProceed: false,\n      allowMultipleUploadBatches: true,\n      debug: false,\n      restrictions: _Restricter_js__WEBPACK_IMPORTED_MODULE_8__.defaultOptions,\n      meta: {},\n      onBeforeFileAdded: (file, files) => !Object.hasOwn(files, file.id),\n      onBeforeUpload: files => files,\n      store: new _uppy_store_default__WEBPACK_IMPORTED_MODULE_3__[\"default\"](),\n      logger: _loggers_js__WEBPACK_IMPORTED_MODULE_9__.justErrorsLogger,\n      infoTimeout: 5000\n    };\n    const merged = {\n      ...defaultOptions,\n      ..._opts\n    };\n    // Merge default options with the ones set by user,\n    // making sure to merge restrictions too\n    this.opts = {\n      ...merged,\n      restrictions: {\n        ...defaultOptions.restrictions,\n        ...(_opts && _opts.restrictions)\n      }\n    };\n\n    // Support debug: true for backwards-compatability, unless logger is set in opts\n    // opts instead of this.opts to avoid comparing objects — we set logger: justErrorsLogger in defaultOptions\n    if (_opts && _opts.logger && _opts.debug) {\n      this.log('You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.', 'warning');\n    } else if (_opts && _opts.debug) {\n      this.opts.logger = _loggers_js__WEBPACK_IMPORTED_MODULE_9__.debugLogger;\n    }\n    this.log(`Using Core v${Uppy.VERSION}`);\n    this.i18nInit();\n    this.store = this.opts.store;\n    this.setState({\n      ...defaultUploadState,\n      plugins: {},\n      files: {},\n      currentUploads: {},\n      capabilities: {\n        uploadProgress: (0,_supportsUploadProgress_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(),\n        individualCancellation: true,\n        resumableUploads: false\n      },\n      meta: {\n        ...this.opts.meta\n      },\n      info: []\n    });\n    _classPrivateFieldLooseBase(this, _restricter)[_restricter] = new _Restricter_js__WEBPACK_IMPORTED_MODULE_8__.Restricter(() => this.opts, () => this.i18n);\n    _classPrivateFieldLooseBase(this, _storeUnsubscribe)[_storeUnsubscribe] = this.store.subscribe((prevState, nextState, patch) => {\n      this.emit('state-update', prevState, nextState, patch);\n      this.updateAll(nextState);\n    });\n\n    // Exposing uppy object on window for debugging and testing\n    if (this.opts.debug && typeof window !== 'undefined') {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore Mutating the global object for debug purposes\n      window[this.opts.id] = this;\n    }\n    _classPrivateFieldLooseBase(this, _addListeners)[_addListeners]();\n  }\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    _classPrivateFieldLooseBase(this, _emitter)[_emitter].emit(event, ...args);\n  }\n  on(event, callback) {\n    _classPrivateFieldLooseBase(this, _emitter)[_emitter].on(event, callback);\n    return this;\n  }\n  once(event, callback) {\n    _classPrivateFieldLooseBase(this, _emitter)[_emitter].once(event, callback);\n    return this;\n  }\n  off(event, callback) {\n    _classPrivateFieldLooseBase(this, _emitter)[_emitter].off(event, callback);\n    return this;\n  }\n\n  /**\n   * Iterate on all plugins and run `update` on them.\n   * Called each time state changes.\n   *\n   */\n  updateAll(state) {\n    this.iteratePlugins(plugin => {\n      plugin.update(state);\n    });\n  }\n\n  /**\n   * Updates state with a patch\n   */\n  setState(patch) {\n    this.store.setState(patch);\n  }\n\n  /**\n   * Returns current state.\n   */\n  getState() {\n    return this.store.getState();\n  }\n  patchFilesState(filesWithNewState) {\n    const existingFilesState = this.getState().files;\n    this.setState({\n      files: {\n        ...existingFilesState,\n        ...Object.fromEntries(Object.entries(filesWithNewState).map(_ref => {\n          let [fileID, newFileState] = _ref;\n          return [fileID, {\n            ...existingFilesState[fileID],\n            ...newFileState\n          }];\n        }))\n      }\n    });\n  }\n\n  /**\n   * Shorthand to set state for a specific file.\n   */\n  setFileState(fileID, state) {\n    if (!this.getState().files[fileID]) {\n      throw new Error(`Can’t set state for ${fileID} (the file could have been removed)`);\n    }\n    this.patchFilesState({\n      [fileID]: state\n    });\n  }\n  i18nInit() {\n    const onMissingKey = key => this.log(`Missing i18n string: ${key}`, 'error');\n    const translator = new _uppy_utils_lib_Translator__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([this.defaultLocale, this.opts.locale], {\n      onMissingKey\n    });\n    this.i18n = translator.translate.bind(translator);\n    this.i18nArray = translator.translateArray.bind(translator);\n    this.locale = translator.locale;\n  }\n  setOptions(newOpts) {\n    this.opts = {\n      ...this.opts,\n      ...newOpts,\n      restrictions: {\n        ...this.opts.restrictions,\n        ...(newOpts == null ? void 0 : newOpts.restrictions)\n      }\n    };\n    if (newOpts.meta) {\n      this.setMeta(newOpts.meta);\n    }\n    this.i18nInit();\n    if (newOpts.locale) {\n      this.iteratePlugins(plugin => {\n        plugin.setOptions(newOpts);\n      });\n    }\n\n    // Note: this is not the preact `setState`, it's an internal function that has the same name.\n    this.setState(undefined); // so that UI re-renders with new options\n  }\n  resetProgress() {\n    const defaultProgress = {\n      percentage: 0,\n      bytesUploaded: false,\n      uploadComplete: false,\n      uploadStarted: null\n    };\n    const files = {\n      ...this.getState().files\n    };\n    const updatedFiles = Object.create(null);\n    Object.keys(files).forEach(fileID => {\n      updatedFiles[fileID] = {\n        ...files[fileID],\n        progress: {\n          ...files[fileID].progress,\n          ...defaultProgress\n        },\n        // @ts-expect-error these typed are inserted\n        // into the namespace in their respective packages\n        // but core isn't ware of those\n        tus: undefined,\n        transloadit: undefined\n      };\n    });\n    this.setState({\n      files: updatedFiles,\n      ...defaultUploadState\n    });\n  }\n  clear() {\n    const {\n      capabilities,\n      currentUploads\n    } = this.getState();\n    if (Object.keys(currentUploads).length > 0 && !capabilities.individualCancellation) {\n      throw new Error('The installed uploader plugin does not allow removing files during an upload.');\n    }\n    this.setState({\n      ...defaultUploadState,\n      files: {}\n    });\n  }\n  addPreProcessor(fn) {\n    _classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors].add(fn);\n  }\n  removePreProcessor(fn) {\n    return _classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors].delete(fn);\n  }\n  addPostProcessor(fn) {\n    _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].add(fn);\n  }\n  removePostProcessor(fn) {\n    return _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].delete(fn);\n  }\n  addUploader(fn) {\n    _classPrivateFieldLooseBase(this, _uploaders)[_uploaders].add(fn);\n  }\n  removeUploader(fn) {\n    return _classPrivateFieldLooseBase(this, _uploaders)[_uploaders].delete(fn);\n  }\n  setMeta(data) {\n    const updatedMeta = {\n      ...this.getState().meta,\n      ...data\n    };\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    Object.keys(updatedFiles).forEach(fileID => {\n      updatedFiles[fileID] = {\n        ...updatedFiles[fileID],\n        meta: {\n          ...updatedFiles[fileID].meta,\n          ...data\n        }\n      };\n    });\n    this.log('Adding metadata:');\n    this.log(data);\n    this.setState({\n      meta: updatedMeta,\n      files: updatedFiles\n    });\n  }\n  setFileMeta(fileID, data) {\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    if (!updatedFiles[fileID]) {\n      this.log(`Was trying to set metadata for a file that has been removed: ${fileID}`);\n      return;\n    }\n    const newMeta = {\n      ...updatedFiles[fileID].meta,\n      ...data\n    };\n    updatedFiles[fileID] = {\n      ...updatedFiles[fileID],\n      meta: newMeta\n    };\n    this.setState({\n      files: updatedFiles\n    });\n  }\n\n  /**\n   * Get a file object.\n   */\n  getFile(fileID) {\n    return this.getState().files[fileID];\n  }\n\n  /**\n   * Get all files in an array.\n   */\n  getFiles() {\n    const {\n      files\n    } = this.getState();\n    return Object.values(files);\n  }\n  getFilesByIds(ids) {\n    return ids.map(id => this.getFile(id));\n  }\n  getObjectOfFilesPerState() {\n    const {\n      files: filesObject,\n      totalProgress,\n      error\n    } = this.getState();\n    const files = Object.values(filesObject);\n    const inProgressFiles = [];\n    const newFiles = [];\n    const startedFiles = [];\n    const uploadStartedFiles = [];\n    const pausedFiles = [];\n    const completeFiles = [];\n    const erroredFiles = [];\n    const inProgressNotPausedFiles = [];\n    const processingFiles = [];\n    for (const file of files) {\n      const {\n        progress\n      } = file;\n      if (!progress.uploadComplete && progress.uploadStarted) {\n        inProgressFiles.push(file);\n        if (!file.isPaused) {\n          inProgressNotPausedFiles.push(file);\n        }\n      }\n      if (!progress.uploadStarted) {\n        newFiles.push(file);\n      }\n      if (progress.uploadStarted || progress.preprocess || progress.postprocess) {\n        startedFiles.push(file);\n      }\n      if (progress.uploadStarted) {\n        uploadStartedFiles.push(file);\n      }\n      if (file.isPaused) {\n        pausedFiles.push(file);\n      }\n      if (progress.uploadComplete) {\n        completeFiles.push(file);\n      }\n      if (file.error) {\n        erroredFiles.push(file);\n      }\n      if (progress.preprocess || progress.postprocess) {\n        processingFiles.push(file);\n      }\n    }\n    return {\n      newFiles,\n      startedFiles,\n      uploadStartedFiles,\n      pausedFiles,\n      completeFiles,\n      erroredFiles,\n      inProgressFiles,\n      inProgressNotPausedFiles,\n      processingFiles,\n      isUploadStarted: uploadStartedFiles.length > 0,\n      isAllComplete: totalProgress === 100 && completeFiles.length === files.length && processingFiles.length === 0,\n      isAllErrored: !!error && erroredFiles.length === files.length,\n      isAllPaused: inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length,\n      isUploadInProgress: inProgressFiles.length > 0,\n      isSomeGhost: files.some(file => file.isGhost)\n    };\n  }\n  validateRestrictions(file, files) {\n    if (files === void 0) {\n      files = this.getFiles();\n    }\n    try {\n      _classPrivateFieldLooseBase(this, _restricter)[_restricter].validate(files, [file]);\n    } catch (err) {\n      return err;\n    }\n    return null;\n  }\n  validateSingleFile(file) {\n    try {\n      _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateSingleFile(file);\n    } catch (err) {\n      return err.message;\n    }\n    return null;\n  }\n  validateAggregateRestrictions(files) {\n    const existingFiles = this.getFiles();\n    try {\n      _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateAggregateRestrictions(existingFiles, files);\n    } catch (err) {\n      return err.message;\n    }\n    return null;\n  }\n  checkIfFileAlreadyExists(fileID) {\n    const {\n      files\n    } = this.getState();\n    if (files[fileID] && !files[fileID].isGhost) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Add a new file to `state.files`. This will run `onBeforeFileAdded`,\n   * try to guess file type in a clever way, check file against restrictions,\n   * and start an upload if `autoProceed === true`.\n   */\n  addFile(file) {\n    _classPrivateFieldLooseBase(this, _assertNewUploadAllowed)[_assertNewUploadAllowed](file);\n    const {\n      nextFilesState,\n      validFilesToAdd,\n      errors\n    } = _classPrivateFieldLooseBase(this, _checkAndUpdateFileState)[_checkAndUpdateFileState]([file]);\n    const restrictionErrors = errors.filter(error => error.isRestriction);\n    _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](restrictionErrors);\n    if (errors.length > 0) throw errors[0];\n    this.setState({\n      files: nextFilesState\n    });\n    const [firstValidFileToAdd] = validFilesToAdd;\n    this.emit('file-added', firstValidFileToAdd);\n    this.emit('files-added', validFilesToAdd);\n    this.log(`Added file: ${firstValidFileToAdd.name}, ${firstValidFileToAdd.id}, mime type: ${firstValidFileToAdd.type}`);\n    _classPrivateFieldLooseBase(this, _startIfAutoProceed)[_startIfAutoProceed]();\n    return firstValidFileToAdd.id;\n  }\n\n  /**\n   * Add multiple files to `state.files`. See the `addFile()` documentation.\n   *\n   * If an error occurs while adding a file, it is logged and the user is notified.\n   * This is good for UI plugins, but not for programmatic use.\n   * Programmatic users should usually still use `addFile()` on individual files.\n   */\n  addFiles(fileDescriptors) {\n    _classPrivateFieldLooseBase(this, _assertNewUploadAllowed)[_assertNewUploadAllowed]();\n    const {\n      nextFilesState,\n      validFilesToAdd,\n      errors\n    } = _classPrivateFieldLooseBase(this, _checkAndUpdateFileState)[_checkAndUpdateFileState](fileDescriptors);\n    const restrictionErrors = errors.filter(error => error.isRestriction);\n    _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](restrictionErrors);\n    const nonRestrictionErrors = errors.filter(error => !error.isRestriction);\n    if (nonRestrictionErrors.length > 0) {\n      let message = 'Multiple errors occurred while adding files:\\n';\n      nonRestrictionErrors.forEach(subError => {\n        message += `\\n * ${subError.message}`;\n      });\n      this.info({\n        message: this.i18n('addBulkFilesFailed', {\n          smart_count: nonRestrictionErrors.length\n        }),\n        details: message\n      }, 'error', this.opts.infoTimeout);\n      if (typeof AggregateError === 'function') {\n        throw new AggregateError(nonRestrictionErrors, message);\n      } else {\n        const err = new Error(message);\n        // @ts-expect-error fallback when AggregateError is not available\n        err.errors = nonRestrictionErrors;\n        throw err;\n      }\n    }\n\n    // OK, we haven't thrown an error, we can start updating state and emitting events now:\n\n    this.setState({\n      files: nextFilesState\n    });\n    validFilesToAdd.forEach(file => {\n      this.emit('file-added', file);\n    });\n    this.emit('files-added', validFilesToAdd);\n    if (validFilesToAdd.length > 5) {\n      this.log(`Added batch of ${validFilesToAdd.length} files`);\n    } else {\n      Object.values(validFilesToAdd).forEach(file => {\n        this.log(`Added file: ${file.name}\\n id: ${file.id}\\n type: ${file.type}`);\n      });\n    }\n    if (validFilesToAdd.length > 0) {\n      _classPrivateFieldLooseBase(this, _startIfAutoProceed)[_startIfAutoProceed]();\n    }\n  }\n  removeFiles(fileIDs) {\n    const {\n      files,\n      currentUploads\n    } = this.getState();\n    const updatedFiles = {\n      ...files\n    };\n    const updatedUploads = {\n      ...currentUploads\n    };\n    const removedFiles = Object.create(null);\n    fileIDs.forEach(fileID => {\n      if (files[fileID]) {\n        removedFiles[fileID] = files[fileID];\n        delete updatedFiles[fileID];\n      }\n    });\n\n    // Remove files from the `fileIDs` list in each upload.\n    function fileIsNotRemoved(uploadFileID) {\n      return removedFiles[uploadFileID] === undefined;\n    }\n    Object.keys(updatedUploads).forEach(uploadID => {\n      const newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved);\n\n      // Remove the upload if no files are associated with it anymore.\n      if (newFileIDs.length === 0) {\n        delete updatedUploads[uploadID];\n        return;\n      }\n      const {\n        capabilities\n      } = this.getState();\n      if (newFileIDs.length !== currentUploads[uploadID].fileIDs.length && !capabilities.individualCancellation) {\n        throw new Error('The installed uploader plugin does not allow removing files during an upload.');\n      }\n      updatedUploads[uploadID] = {\n        ...currentUploads[uploadID],\n        fileIDs: newFileIDs\n      };\n    });\n    const stateUpdate = {\n      currentUploads: updatedUploads,\n      files: updatedFiles\n    };\n\n    // If all files were removed - allow new uploads,\n    // and clear recoveredState\n    if (Object.keys(updatedFiles).length === 0) {\n      stateUpdate.allowNewUpload = true;\n      stateUpdate.error = null;\n      stateUpdate.recoveredState = null;\n    }\n    this.setState(stateUpdate);\n    _classPrivateFieldLooseBase(this, _updateTotalProgressThrottled)[_updateTotalProgressThrottled]();\n    const removedFileIDs = Object.keys(removedFiles);\n    removedFileIDs.forEach(fileID => {\n      this.emit('file-removed', removedFiles[fileID]);\n    });\n    if (removedFileIDs.length > 5) {\n      this.log(`Removed ${removedFileIDs.length} files`);\n    } else {\n      this.log(`Removed files: ${removedFileIDs.join(', ')}`);\n    }\n  }\n  removeFile(fileID) {\n    this.removeFiles([fileID]);\n  }\n  pauseResume(fileID) {\n    if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).progress.uploadComplete) {\n      return undefined;\n    }\n    const file = this.getFile(fileID);\n    const wasPaused = file.isPaused || false;\n    const isPaused = !wasPaused;\n    this.setFileState(fileID, {\n      isPaused\n    });\n    this.emit('upload-pause', file, isPaused);\n    return isPaused;\n  }\n  pauseAll() {\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter(file => {\n      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;\n    });\n    inProgressUpdatedFiles.forEach(file => {\n      const updatedFile = {\n        ...updatedFiles[file],\n        isPaused: true\n      };\n      updatedFiles[file] = updatedFile;\n    });\n    this.setState({\n      files: updatedFiles\n    });\n    this.emit('pause-all');\n  }\n  resumeAll() {\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter(file => {\n      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;\n    });\n    inProgressUpdatedFiles.forEach(file => {\n      const updatedFile = {\n        ...updatedFiles[file],\n        isPaused: false,\n        error: null\n      };\n      updatedFiles[file] = updatedFile;\n    });\n    this.setState({\n      files: updatedFiles\n    });\n    this.emit('resume-all');\n  }\n  retryAll() {\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    const filesToRetry = Object.keys(updatedFiles).filter(file => {\n      return updatedFiles[file].error;\n    });\n    filesToRetry.forEach(file => {\n      const updatedFile = {\n        ...updatedFiles[file],\n        isPaused: false,\n        error: null\n      };\n      updatedFiles[file] = updatedFile;\n    });\n    this.setState({\n      files: updatedFiles,\n      error: null\n    });\n    this.emit('retry-all', Object.values(updatedFiles));\n    if (filesToRetry.length === 0) {\n      return Promise.resolve({\n        successful: [],\n        failed: []\n      });\n    }\n    const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](filesToRetry, {\n      forceAllowNewUpload: true // create new upload even if allowNewUpload: false\n    });\n    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);\n  }\n  cancelAll() {\n    this.emit('cancel-all');\n    const {\n      files\n    } = this.getState();\n    const fileIDs = Object.keys(files);\n    if (fileIDs.length) {\n      this.removeFiles(fileIDs);\n    }\n    this.setState(defaultUploadState);\n  }\n  retryUpload(fileID) {\n    this.setFileState(fileID, {\n      error: null,\n      isPaused: false\n    });\n    this.emit('upload-retry', this.getFile(fileID));\n    const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload]([fileID], {\n      forceAllowNewUpload: true // create new upload even if allowNewUpload: false\n    });\n    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);\n  }\n  logout() {\n    this.iteratePlugins(plugin => {\n      var _provider;\n      ;\n      (_provider = plugin.provider) == null || _provider.logout == null || _provider.logout();\n    });\n  }\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/explicit-module-boundary-types\n  [Symbol.for('uppy test: updateTotalProgress')]() {\n    return _classPrivateFieldLooseBase(this, _updateTotalProgress)[_updateTotalProgress]();\n  }\n  updateOnlineStatus() {\n    var _window$navigator$onL;\n    const online = (_window$navigator$onL = window.navigator.onLine) != null ? _window$navigator$onL : true;\n    if (!online) {\n      this.emit('is-offline');\n      this.info(this.i18n('noInternetConnection'), 'error', 0);\n      this.wasOffline = true;\n    } else {\n      this.emit('is-online');\n      if (this.wasOffline) {\n        this.emit('back-online');\n        this.info(this.i18n('connectedToInternet'), 'success', 3000);\n        this.wasOffline = false;\n      }\n    }\n  }\n  getID() {\n    return this.opts.id;\n  }\n\n  /**\n   * Registers a plugin with Core.\n   */\n  use(Plugin) {\n    if (typeof Plugin !== 'function') {\n      const msg = `Expected a plugin class, but got ${Plugin === null ? 'null' : typeof Plugin}.` + ' Please verify that the plugin was imported and spelled correctly.';\n      throw new TypeError(msg);\n    }\n\n    // Instantiate\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    const plugin = new Plugin(this, ...args);\n    const pluginId = plugin.id;\n    if (!pluginId) {\n      throw new Error('Your plugin must have an id');\n    }\n    if (!plugin.type) {\n      throw new Error('Your plugin must have a type');\n    }\n    const existsPluginAlready = this.getPlugin(pluginId);\n    if (existsPluginAlready) {\n      const msg = `Already found a plugin named '${existsPluginAlready.id}'. ` + `Tried to use: '${pluginId}'.\\n` + 'Uppy plugins must have unique `id` options.';\n      throw new Error(msg);\n    }\n\n    // @ts-expect-error does exist\n    if (Plugin.VERSION) {\n      // @ts-expect-error does exist\n      this.log(`Using ${pluginId} v${Plugin.VERSION}`);\n    }\n    if (plugin.type in _classPrivateFieldLooseBase(this, _plugins)[_plugins]) {\n      _classPrivateFieldLooseBase(this, _plugins)[_plugins][plugin.type].push(plugin);\n    } else {\n      _classPrivateFieldLooseBase(this, _plugins)[_plugins][plugin.type] = [plugin];\n    }\n    plugin.install();\n    this.emit('plugin-added', plugin);\n    return this;\n  }\n\n  /**\n   * Find one Plugin by name.\n   */\n  getPlugin(id) {\n    for (const plugins of Object.values(_classPrivateFieldLooseBase(this, _plugins)[_plugins])) {\n      const foundPlugin = plugins.find(plugin => plugin.id === id);\n      if (foundPlugin != null) return foundPlugin;\n    }\n    return undefined;\n  }\n  [Symbol.for('uppy test: getPlugins')](type) {\n    return _classPrivateFieldLooseBase(this, _plugins)[_plugins][type];\n  }\n\n  /**\n   * Iterate through all `use`d plugins.\n   *\n   */\n  iteratePlugins(method) {\n    Object.values(_classPrivateFieldLooseBase(this, _plugins)[_plugins]).flat(1).forEach(method);\n  }\n\n  /**\n   * Uninstall and remove a plugin.\n   *\n   * @param {object} instance The plugin instance to remove.\n   */\n  removePlugin(instance) {\n    this.log(`Removing plugin ${instance.id}`);\n    this.emit('plugin-remove', instance);\n    if (instance.uninstall) {\n      instance.uninstall();\n    }\n    const list = _classPrivateFieldLooseBase(this, _plugins)[_plugins][instance.type];\n    // list.indexOf failed here, because Vue3 converted the plugin instance\n    // to a Proxy object, which failed the strict comparison test:\n    // obj !== objProxy\n    const index = list.findIndex(item => item.id === instance.id);\n    if (index !== -1) {\n      list.splice(index, 1);\n    }\n    const state = this.getState();\n    const updatedState = {\n      plugins: {\n        ...state.plugins,\n        [instance.id]: undefined\n      }\n    };\n    this.setState(updatedState);\n  }\n\n  /**\n   * Uninstall all plugins and close down this Uppy instance.\n   */\n  destroy() {\n    this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`);\n    this.cancelAll();\n    _classPrivateFieldLooseBase(this, _storeUnsubscribe)[_storeUnsubscribe]();\n    this.iteratePlugins(plugin => {\n      this.removePlugin(plugin);\n    });\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('online', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);\n      window.removeEventListener('offline', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);\n    }\n  }\n  hideInfo() {\n    const {\n      info\n    } = this.getState();\n    this.setState({\n      info: info.slice(1)\n    });\n    this.emit('info-hidden');\n  }\n\n  /**\n   * Set info message in `state.info`, so that UI plugins like `Informer`\n   * can display the message.\n   */\n  info(message, type, duration) {\n    if (type === void 0) {\n      type = 'info';\n    }\n    if (duration === void 0) {\n      duration = 3000;\n    }\n    const isComplexMessage = typeof message === 'object';\n    this.setState({\n      info: [...this.getState().info, {\n        type,\n        message: isComplexMessage ? message.message : message,\n        details: isComplexMessage ? message.details : null\n      }]\n    });\n    setTimeout(() => this.hideInfo(), duration);\n    this.emit('info-visible');\n  }\n\n  /**\n   * Passes messages to a function, provided in `opts.logger`.\n   * If `opts.logger: Uppy.debugLogger` or `opts.debug: true`, logs to the browser console.\n   */\n  log(message, type) {\n    const {\n      logger\n    } = this.opts;\n    switch (type) {\n      case 'error':\n        logger.error(message);\n        break;\n      case 'warning':\n        logger.warn(message);\n        break;\n      default:\n        logger.debug(message);\n        break;\n    }\n  }\n  registerRequestClient(id, client) {\n    _classPrivateFieldLooseBase(this, _requestClientById)[_requestClientById].set(id, client);\n  }\n\n  /** @protected */\n  getRequestClientForFile(file) {\n    if (!file.remote) throw new Error(`Tried to get RequestClient for a non-remote file ${file.id}`);\n    const requestClient = _classPrivateFieldLooseBase(this, _requestClientById)[_requestClientById].get(file.remote.requestClientId);\n    if (requestClient == null) throw new Error(`requestClientId \"${file.remote.requestClientId}\" not registered for file \"${file.id}\"`);\n    return requestClient;\n  }\n\n  /**\n   * Restore an upload by its ID.\n   */\n  restore(uploadID) {\n    this.log(`Core: attempting to restore upload \"${uploadID}\"`);\n    if (!this.getState().currentUploads[uploadID]) {\n      _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);\n      return Promise.reject(new Error('Nonexistent upload'));\n    }\n    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);\n  }\n  [Symbol.for('uppy test: createUpload')]() {\n    // @ts-expect-error https://github.com/microsoft/TypeScript/issues/47595\n    return _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](...arguments);\n  }\n  /**\n   * Add data to an upload's result object.\n   */\n  addResultData(uploadID, data) {\n    if (!_classPrivateFieldLooseBase(this, _getUpload)[_getUpload](uploadID)) {\n      this.log(`Not setting result for an upload that has been removed: ${uploadID}`);\n      return;\n    }\n    const {\n      currentUploads\n    } = this.getState();\n    const currentUpload = {\n      ...currentUploads[uploadID],\n      result: {\n        ...currentUploads[uploadID].result,\n        ...data\n      }\n    };\n    this.setState({\n      currentUploads: {\n        ...currentUploads,\n        [uploadID]: currentUpload\n      }\n    });\n  }\n  /**\n   * Start an upload for all the files that are not currently being uploaded.\n   */\n  upload() {\n    var _classPrivateFieldLoo;\n    if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _plugins)[_plugins]['uploader']) != null && _classPrivateFieldLoo.length)) {\n      this.log('No uploader type plugins are used', 'warning');\n    }\n    let {\n      files\n    } = this.getState();\n    const onBeforeUploadResult = this.opts.onBeforeUpload(files);\n    if (onBeforeUploadResult === false) {\n      return Promise.reject(new Error('Not starting the upload because onBeforeUpload returned false'));\n    }\n    if (onBeforeUploadResult && typeof onBeforeUploadResult === 'object') {\n      files = onBeforeUploadResult;\n      // Updating files in state, because uploader plugins receive file IDs,\n      // and then fetch the actual file object from state\n      this.setState({\n        files\n      });\n    }\n    return Promise.resolve().then(() => _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateMinNumberOfFiles(files)).catch(err => {\n      _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit]([err]);\n      throw err;\n    }).then(() => {\n      if (!_classPrivateFieldLooseBase(this, _checkRequiredMetaFields)[_checkRequiredMetaFields](files)) {\n        throw new _Restricter_js__WEBPACK_IMPORTED_MODULE_8__.RestrictionError(this.i18n('missingRequiredMetaField'));\n      }\n    }).catch(err => {\n      // Doing this in a separate catch because we already emited and logged\n      // all the errors in `checkRequiredMetaFields` so we only throw a generic\n      // missing fields error here.\n      throw err;\n    }).then(() => {\n      const {\n        currentUploads\n      } = this.getState();\n      // get a list of files that are currently assigned to uploads\n      const currentlyUploadingFiles = Object.values(currentUploads).flatMap(curr => curr.fileIDs);\n      const waitingFileIDs = [];\n      Object.keys(files).forEach(fileID => {\n        const file = this.getFile(fileID);\n        // if the file hasn't started uploading and hasn't already been assigned to an upload..\n        if (!file.progress.uploadStarted && currentlyUploadingFiles.indexOf(fileID) === -1) {\n          waitingFileIDs.push(file.id);\n        }\n      });\n      const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](waitingFileIDs);\n      return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);\n    }).catch(err => {\n      this.emit('error', err);\n      this.log(err, 'error');\n      throw err;\n    });\n  }\n}\nfunction _informAndEmit2(errors) {\n  for (const error of errors) {\n    if (error.isRestriction) {\n      this.emit('restriction-failed', error.file, error);\n    } else {\n      this.emit('error', error, error.file);\n    }\n    this.log(error, 'warning');\n  }\n  const userFacingErrors = errors.filter(error => error.isUserFacing);\n\n  // don't flood the user: only show the first 4 toasts\n  const maxNumToShow = 4;\n  const firstErrors = userFacingErrors.slice(0, maxNumToShow);\n  const additionalErrors = userFacingErrors.slice(maxNumToShow);\n  firstErrors.forEach(_ref2 => {\n    let {\n      message,\n      details = ''\n    } = _ref2;\n    this.info({\n      message,\n      details\n    }, 'error', this.opts.infoTimeout);\n  });\n  if (additionalErrors.length > 0) {\n    this.info({\n      message: this.i18n('additionalRestrictionsFailed', {\n        count: additionalErrors.length\n      })\n    });\n  }\n}\nfunction _checkRequiredMetaFieldsOnFile2(file) {\n  const {\n    missingFields,\n    error\n  } = _classPrivateFieldLooseBase(this, _restricter)[_restricter].getMissingRequiredMetaFields(file);\n  if (missingFields.length > 0) {\n    this.setFileState(file.id, {\n      missingRequiredMetaFields: missingFields\n    });\n    this.log(error.message);\n    this.emit('restriction-failed', file, error);\n    return false;\n  }\n  return true;\n}\nfunction _checkRequiredMetaFields2(files) {\n  let success = true;\n  for (const file of Object.values(files)) {\n    if (!_classPrivateFieldLooseBase(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file)) {\n      success = false;\n    }\n  }\n  return success;\n}\nfunction _assertNewUploadAllowed2(file) {\n  const {\n    allowNewUpload\n  } = this.getState();\n  if (allowNewUpload === false) {\n    const error = new _Restricter_js__WEBPACK_IMPORTED_MODULE_8__.RestrictionError(this.i18n('noMoreFilesAllowed'), {\n      file\n    });\n    _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit]([error]);\n    throw error;\n  }\n}\nfunction _transformFile2(fileDescriptorOrFile) {\n  // Uppy expects files in { name, type, size, data } format.\n  // If the actual File object is passed from input[type=file] or drag-drop,\n  // we normalize it to match Uppy file object\n  const file = fileDescriptorOrFile instanceof File ? {\n    name: fileDescriptorOrFile.name,\n    type: fileDescriptorOrFile.type,\n    size: fileDescriptorOrFile.size,\n    data: fileDescriptorOrFile\n  } : fileDescriptorOrFile;\n  const fileType = (0,_uppy_utils_lib_getFileType__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(file);\n  const fileName = (0,_getFileName_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(fileType, file);\n  const fileExtension = (0,_uppy_utils_lib_getFileNameAndExtension__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(fileName).extension;\n  const id = (0,_uppy_utils_lib_generateFileID__WEBPACK_IMPORTED_MODULE_6__.getSafeFileId)(file, this.getID());\n  const meta = file.meta || {};\n  meta.name = fileName;\n  meta.type = fileType;\n\n  // `null` means the size is unknown.\n  const size = Number.isFinite(file.data.size) ? file.data.size : null;\n  return {\n    source: file.source || '',\n    id,\n    name: fileName,\n    extension: fileExtension || '',\n    meta: {\n      ...this.getState().meta,\n      ...meta\n    },\n    type: fileType,\n    data: file.data,\n    progress: {\n      percentage: 0,\n      bytesUploaded: false,\n      bytesTotal: size,\n      uploadComplete: false,\n      uploadStarted: null\n    },\n    size,\n    isGhost: false,\n    isRemote: file.isRemote || false,\n    remote: file.remote,\n    preview: file.preview\n  };\n}\nfunction _startIfAutoProceed2() {\n  if (this.opts.autoProceed && !this.scheduledAutoProceed) {\n    this.scheduledAutoProceed = setTimeout(() => {\n      this.scheduledAutoProceed = null;\n      this.upload().catch(err => {\n        if (!err.isRestriction) {\n          this.log(err.stack || err.message || err);\n        }\n      });\n    }, 4);\n  }\n}\nfunction _checkAndUpdateFileState2(filesToAdd) {\n  const {\n    files: existingFiles\n  } = this.getState();\n\n  // create a copy of the files object only once\n  const nextFilesState = {\n    ...existingFiles\n  };\n  const validFilesToAdd = [];\n  const errors = [];\n  for (const fileToAdd of filesToAdd) {\n    try {\n      var _existingFiles$newFil;\n      let newFile = _classPrivateFieldLooseBase(this, _transformFile)[_transformFile](fileToAdd);\n\n      // If a file has been recovered (Golden Retriever), but we were unable to recover its data (probably too large),\n      // users are asked to re-select these half-recovered files and then this method will be called again.\n      // In order to keep the progress, meta and everything else, we keep the existing file,\n      // but we replace `data`, and we remove `isGhost`, because the file is no longer a ghost now\n      const isGhost = (_existingFiles$newFil = existingFiles[newFile.id]) == null ? void 0 : _existingFiles$newFil.isGhost;\n      if (isGhost) {\n        const existingFileState = existingFiles[newFile.id];\n        newFile = {\n          ...existingFileState,\n          isGhost: false,\n          data: fileToAdd.data\n        };\n        this.log(`Replaced the blob in the restored ghost file: ${newFile.name}, ${newFile.id}`);\n      }\n      const onBeforeFileAddedResult = this.opts.onBeforeFileAdded(newFile, nextFilesState);\n      if (!onBeforeFileAddedResult && this.checkIfFileAlreadyExists(newFile.id)) {\n        var _newFile$name;\n        throw new _Restricter_js__WEBPACK_IMPORTED_MODULE_8__.RestrictionError(this.i18n('noDuplicates', {\n          fileName: (_newFile$name = newFile.name) != null ? _newFile$name : this.i18n('unnamed')\n        }), {\n          file: fileToAdd\n        });\n      }\n\n      // Pass through reselected files from Golden Retriever\n      if (onBeforeFileAddedResult === false && !isGhost) {\n        // Don’t show UI info for this error, as it should be done by the developer\n        throw new _Restricter_js__WEBPACK_IMPORTED_MODULE_8__.RestrictionError('Cannot add the file because onBeforeFileAdded returned false.', {\n          isUserFacing: false,\n          file: fileToAdd\n        });\n      } else if (typeof onBeforeFileAddedResult === 'object' && onBeforeFileAddedResult !== null) {\n        newFile = onBeforeFileAddedResult;\n      }\n      _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateSingleFile(newFile);\n\n      // need to add it to the new local state immediately, so we can use the state to validate the next files too\n      nextFilesState[newFile.id] = newFile;\n      validFilesToAdd.push(newFile);\n    } catch (err) {\n      errors.push(err);\n    }\n  }\n  try {\n    // need to run this separately because it's much more slow, so if we run it inside the for-loop it will be very slow\n    // when many files are added\n    _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateAggregateRestrictions(Object.values(existingFiles), validFilesToAdd);\n  } catch (err) {\n    errors.push(err);\n\n    // If we have any aggregate error, don't allow adding this batch\n    return {\n      nextFilesState: existingFiles,\n      validFilesToAdd: [],\n      errors\n    };\n  }\n  return {\n    nextFilesState,\n    validFilesToAdd,\n    errors\n  };\n}\nfunction _updateTotalProgress2() {\n  var _totalProgressPercent, _totalProgressPercent2;\n  const totalProgress = _classPrivateFieldLooseBase(this, _calculateTotalProgress)[_calculateTotalProgress]();\n  let totalProgressPercent = null;\n  if (totalProgress != null) {\n    totalProgressPercent = Math.round(totalProgress * 100);\n    if (totalProgressPercent > 100) totalProgressPercent = 100;else if (totalProgressPercent < 0) totalProgressPercent = 0;\n  }\n  this.emit('progress', (_totalProgressPercent = totalProgressPercent) != null ? _totalProgressPercent : 0);\n  this.setState({\n    totalProgress: (_totalProgressPercent2 = totalProgressPercent) != null ? _totalProgressPercent2 : 0\n  });\n}\nfunction _calculateTotalProgress2() {\n  // calculate total progress, using the number of files currently uploading,\n  // between 0 and 1 and sum of individual progress of each file\n  const files = this.getFiles();\n\n  // note: also includes files that have completed uploading:\n  const filesInProgress = files.filter(file => {\n    return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;\n  });\n  if (filesInProgress.length === 0) {\n    return 0;\n  }\n  if (filesInProgress.every(file => file.progress.uploadComplete)) {\n    // If every uploading file is complete, and we're still getting progress, it probably means\n    // there's a bug somewhere in some progress reporting code (maybe not even our code)\n    // and we're still getting progress, so let's just assume it means a 100% progress\n    return 1;\n  }\n  const isSizedFile = file => file.progress.bytesTotal != null && file.progress.bytesTotal !== 0;\n  const sizedFilesInProgress = filesInProgress.filter(isSizedFile);\n  const unsizedFilesInProgress = filesInProgress.filter(file => !isSizedFile(file));\n  if (sizedFilesInProgress.every(file => file.progress.uploadComplete) && unsizedFilesInProgress.length > 0 && !unsizedFilesInProgress.every(file => file.progress.uploadComplete)) {\n    // we are done with uploading all files of known size, however\n    // there is at least one file with unknown size still uploading,\n    // and we cannot say anything about their progress\n    // In any case, return null because it doesn't make any sense to show a progress\n    return null;\n  }\n  const totalFilesSize = sizedFilesInProgress.reduce((acc, file) => {\n    var _file$progress$bytesT;\n    return acc + ((_file$progress$bytesT = file.progress.bytesTotal) != null ? _file$progress$bytesT : 0);\n  }, 0);\n  const totalUploadedSize = sizedFilesInProgress.reduce((acc, file) => acc + (file.progress.bytesUploaded || 0), 0);\n  return totalFilesSize === 0 ? 0 : totalUploadedSize / totalFilesSize;\n}\nfunction _addListeners2() {\n  // Type inference only works for inline functions so we have to type it again\n  const errorHandler = (error, file, response) => {\n    let errorMsg = error.message || 'Unknown error';\n    if (error.details) {\n      errorMsg += ` ${error.details}`;\n    }\n    this.setState({\n      error: errorMsg\n    });\n    if (file != null && file.id in this.getState().files) {\n      this.setFileState(file.id, {\n        error: errorMsg,\n        response\n      });\n    }\n  };\n  this.on('error', errorHandler);\n  this.on('upload-error', (file, error, response) => {\n    errorHandler(error, file, response);\n    if (typeof error === 'object' && error.message) {\n      var _file$name;\n      this.log(error.message, 'error');\n      const newError = new Error(this.i18n('failedToUpload', {\n        file: (_file$name = file == null ? void 0 : file.name) != null ? _file$name : ''\n      })); // we may want a new custom error here\n      newError.isUserFacing = true; // todo maybe don't do this with all errors?\n      newError.details = error.message;\n      if (error.details) {\n        newError.details += ` ${error.details}`;\n      }\n      _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit]([newError]);\n    } else {\n      _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit]([error]);\n    }\n  });\n  let uploadStalledWarningRecentlyEmitted = null;\n  this.on('upload-stalled', (error, files) => {\n    const {\n      message\n    } = error;\n    const details = files.map(file => file.meta.name).join(', ');\n    if (!uploadStalledWarningRecentlyEmitted) {\n      this.info({\n        message,\n        details\n      }, 'warning', this.opts.infoTimeout);\n      uploadStalledWarningRecentlyEmitted = setTimeout(() => {\n        uploadStalledWarningRecentlyEmitted = null;\n      }, this.opts.infoTimeout);\n    }\n    this.log(`${message} ${details}`.trim(), 'warning');\n  });\n  this.on('upload', () => {\n    this.setState({\n      error: null\n    });\n  });\n  const onUploadStarted = files => {\n    const filesFiltered = files.filter(file => {\n      const exists = file != null && this.getFile(file.id);\n      if (!exists) this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return exists;\n    });\n    const filesState = Object.fromEntries(filesFiltered.map(file => [file.id, {\n      progress: {\n        uploadStarted: Date.now(),\n        uploadComplete: false,\n        bytesUploaded: 0,\n        bytesTotal: file.size\n      }\n    }]));\n    this.patchFilesState(filesState);\n  };\n  this.on('upload-start', onUploadStarted);\n  this.on('upload-progress', _classPrivateFieldLooseBase(this, _handleUploadProgress)[_handleUploadProgress]);\n  this.on('upload-success', (file, uploadResp) => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    const currentProgress = this.getFile(file.id).progress;\n    this.setFileState(file.id, {\n      progress: {\n        ...currentProgress,\n        postprocess: _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].size > 0 ? {\n          mode: 'indeterminate'\n        } : undefined,\n        uploadComplete: true,\n        percentage: 100,\n        bytesUploaded: currentProgress.bytesTotal\n      },\n      response: uploadResp,\n      uploadURL: uploadResp.uploadURL,\n      isPaused: false\n    });\n\n    // Remote providers sometimes don't tell us the file size,\n    // but we can know how many bytes we uploaded once the upload is complete.\n    if (file.size == null) {\n      this.setFileState(file.id, {\n        size: uploadResp.bytesUploaded || currentProgress.bytesTotal\n      });\n    }\n    _classPrivateFieldLooseBase(this, _updateTotalProgressThrottled)[_updateTotalProgressThrottled]();\n  });\n  this.on('preprocess-progress', (file, progress) => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    this.setFileState(file.id, {\n      progress: {\n        ...this.getFile(file.id).progress,\n        preprocess: progress\n      }\n    });\n  });\n  this.on('preprocess-complete', file => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    const files = {\n      ...this.getState().files\n    };\n    files[file.id] = {\n      ...files[file.id],\n      progress: {\n        ...files[file.id].progress\n      }\n    };\n    delete files[file.id].progress.preprocess;\n    this.setState({\n      files\n    });\n  });\n  this.on('postprocess-progress', (file, progress) => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    this.setFileState(file.id, {\n      progress: {\n        ...this.getState().files[file.id].progress,\n        postprocess: progress\n      }\n    });\n  });\n  this.on('postprocess-complete', file => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    const files = {\n      ...this.getState().files\n    };\n    files[file.id] = {\n      ...files[file.id],\n      progress: {\n        ...files[file.id].progress\n      }\n    };\n    delete files[file.id].progress.postprocess;\n    this.setState({\n      files\n    });\n  });\n  this.on('restored', () => {\n    // Files may have changed--ensure progress is still accurate.\n    _classPrivateFieldLooseBase(this, _updateTotalProgressThrottled)[_updateTotalProgressThrottled]();\n  });\n\n  // @ts-expect-error should fix itself when dashboard it typed (also this doesn't belong here)\n  this.on('dashboard:file-edit-complete', file => {\n    if (file) {\n      _classPrivateFieldLooseBase(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file);\n    }\n  });\n\n  // show informer if offline\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('online', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);\n    window.addEventListener('offline', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);\n    setTimeout(_classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus], 3000);\n  }\n}\nfunction _createUpload2(fileIDs, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // uppy.retryAll sets this to true — when retrying we want to ignore `allowNewUpload: false`\n  const {\n    forceAllowNewUpload = false\n  } = opts;\n  const {\n    allowNewUpload,\n    currentUploads\n  } = this.getState();\n  if (!allowNewUpload && !forceAllowNewUpload) {\n    throw new Error('Cannot create a new upload: already uploading.');\n  }\n  const uploadID = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_12__.nanoid)();\n  this.emit('upload', uploadID, this.getFilesByIds(fileIDs));\n  this.setState({\n    allowNewUpload: this.opts.allowMultipleUploadBatches !== false && this.opts.allowMultipleUploads !== false,\n    currentUploads: {\n      ...currentUploads,\n      [uploadID]: {\n        fileIDs,\n        step: 0,\n        result: {}\n      }\n    }\n  });\n  return uploadID;\n}\nfunction _getUpload2(uploadID) {\n  const {\n    currentUploads\n  } = this.getState();\n  return currentUploads[uploadID];\n}\nfunction _removeUpload2(uploadID) {\n  const currentUploads = {\n    ...this.getState().currentUploads\n  };\n  delete currentUploads[uploadID];\n  this.setState({\n    currentUploads\n  });\n}\nasync function _runUpload2(uploadID) {\n  const getCurrentUpload = () => {\n    const {\n      currentUploads\n    } = this.getState();\n    return currentUploads[uploadID];\n  };\n  let currentUpload = getCurrentUpload();\n  const steps = [..._classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors], ..._classPrivateFieldLooseBase(this, _uploaders)[_uploaders], ..._classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors]];\n  try {\n    for (let step = currentUpload.step || 0; step < steps.length; step++) {\n      if (!currentUpload) {\n        break;\n      }\n      const fn = steps[step];\n      this.setState({\n        currentUploads: {\n          ...this.getState().currentUploads,\n          [uploadID]: {\n            ...currentUpload,\n            step\n          }\n        }\n      });\n      const {\n        fileIDs\n      } = currentUpload;\n\n      // TODO give this the `updatedUpload` object as its only parameter maybe?\n      // Otherwise when more metadata may be added to the upload this would keep getting more parameters\n      await fn(fileIDs, uploadID);\n\n      // Update currentUpload value in case it was modified asynchronously.\n      currentUpload = getCurrentUpload();\n    }\n  } catch (err) {\n    _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);\n    throw err;\n  }\n\n  // Set result data.\n  if (currentUpload) {\n    // Mark postprocessing step as complete if necessary; this addresses a case where we might get\n    // stuck in the postprocessing UI while the upload is fully complete.\n    // If the postprocessing steps do not do any work, they may not emit postprocessing events at\n    // all, and never mark the postprocessing as complete. This is fine on its own but we\n    // introduced code in the @uppy/core upload-success handler to prepare postprocessing progress\n    // state if any postprocessors are registered. That is to avoid a \"flash of completed state\"\n    // before the postprocessing plugins can emit events.\n    //\n    // So, just in case an upload with postprocessing plugins *has* completed *without* emitting\n    // postprocessing completion, we do it instead.\n    currentUpload.fileIDs.forEach(fileID => {\n      const file = this.getFile(fileID);\n      if (file && file.progress.postprocess) {\n        this.emit('postprocess-complete', file);\n      }\n    });\n    const files = currentUpload.fileIDs.map(fileID => this.getFile(fileID));\n    const successful = files.filter(file => !file.error);\n    const failed = files.filter(file => file.error);\n    this.addResultData(uploadID, {\n      successful,\n      failed,\n      uploadID\n    });\n\n    // Update currentUpload value in case it was modified asynchronously.\n    currentUpload = getCurrentUpload();\n  }\n  // Emit completion events.\n  // This is in a separate function so that the `currentUploads` variable\n  // always refers to the latest state. In the handler right above it refers\n  // to an outdated object without the `.result` property.\n  let result;\n  if (currentUpload) {\n    result = currentUpload.result;\n    this.emit('complete', result);\n    _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);\n  }\n  if (result == null) {\n    this.log(`Not setting result for an upload that has been removed: ${uploadID}`);\n  }\n  return result;\n}\nUppy.VERSION = packageJson.version;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Uppy);\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/core/lib/Uppy.js?");

/***/ }),

/***/ "./node_modules/@uppy/core/lib/getFileName.js":
/*!****************************************************!*\
  !*** ./node_modules/@uppy/core/lib/getFileName.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getFileName)\n/* harmony export */ });\nfunction getFileName(fileType, fileDescriptor) {\n  if (fileDescriptor.name) {\n    return fileDescriptor.name;\n  }\n  if (fileType.split('/')[0] === 'image') {\n    return `${fileType.split('/')[0]}.${fileType.split('/')[1]}`;\n  }\n  return 'noname';\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/core/lib/getFileName.js?");

/***/ }),

/***/ "./node_modules/@uppy/core/lib/locale.js":
/*!***********************************************!*\
  !*** ./node_modules/@uppy/core/lib/locale.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  strings: {\n    addBulkFilesFailed: {\n      0: 'Failed to add %{smart_count} file due to an internal error',\n      1: 'Failed to add %{smart_count} files due to internal errors'\n    },\n    youCanOnlyUploadX: {\n      0: 'You can only upload %{smart_count} file',\n      1: 'You can only upload %{smart_count} files'\n    },\n    youHaveToAtLeastSelectX: {\n      0: 'You have to select at least %{smart_count} file',\n      1: 'You have to select at least %{smart_count} files'\n    },\n    aggregateExceedsSize: 'You selected %{size} of files, but maximum allowed size is %{sizeAllowed}',\n    exceedsSize: '%{file} exceeds maximum allowed size of %{size}',\n    missingRequiredMetaField: 'Missing required meta fields',\n    missingRequiredMetaFieldOnFile: 'Missing required meta fields in %{fileName}',\n    inferiorSize: 'This file is smaller than the allowed size of %{size}',\n    youCanOnlyUploadFileTypes: 'You can only upload: %{types}',\n    noMoreFilesAllowed: 'Cannot add more files',\n    noDuplicates: \"Cannot add the duplicate file '%{fileName}', it already exists\",\n    companionError: 'Connection with Companion failed',\n    authAborted: 'Authentication aborted',\n    companionUnauthorizeHint: 'To unauthorize to your %{provider} account, please go to %{url}',\n    failedToUpload: 'Failed to upload %{file}',\n    noInternetConnection: 'No Internet connection',\n    connectedToInternet: 'Connected to the Internet',\n    // Strings for remote providers\n    noFilesFound: 'You have no files or folders here',\n    noSearchResults: 'Unfortunately, there are no results for this search',\n    selectX: {\n      0: 'Select %{smart_count}',\n      1: 'Select %{smart_count}'\n    },\n    allFilesFromFolderNamed: 'All files from folder %{name}',\n    openFolderNamed: 'Open folder %{name}',\n    cancel: 'Cancel',\n    logOut: 'Log out',\n    logIn: 'Log in',\n    pickFiles: 'Pick files',\n    pickPhotos: 'Pick photos',\n    filter: 'Filter',\n    resetFilter: 'Reset filter',\n    loading: 'Loading...',\n    loadedXFiles: 'Loaded %{numFiles} files',\n    authenticateWithTitle: 'Please authenticate with %{pluginName} to select files',\n    authenticateWith: 'Connect to %{pluginName}',\n    signInWithGoogle: 'Sign in with Google',\n    searchImages: 'Search for images',\n    enterTextToSearch: 'Enter text to search for images',\n    search: 'Search',\n    resetSearch: 'Reset search',\n    emptyFolderAdded: 'No files were added from empty folder',\n    addedNumFiles: 'Added %{numFiles} file(s)',\n    folderAlreadyAdded: 'The folder \"%{folder}\" was already added',\n    folderAdded: {\n      0: 'Added %{smart_count} file from %{folder}',\n      1: 'Added %{smart_count} files from %{folder}'\n    },\n    additionalRestrictionsFailed: '%{count} additional restrictions were not fulfilled',\n    unnamed: 'Unnamed',\n    pleaseWait: 'Please wait'\n  }\n});\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/core/lib/locale.js?");

/***/ }),

/***/ "./node_modules/@uppy/core/lib/loggers.js":
/*!************************************************!*\
  !*** ./node_modules/@uppy/core/lib/loggers.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   debugLogger: () => (/* binding */ debugLogger),\n/* harmony export */   justErrorsLogger: () => (/* binding */ justErrorsLogger)\n/* harmony export */ });\n/* harmony import */ var _uppy_utils_lib_getTimeStamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uppy/utils/lib/getTimeStamp */ \"./node_modules/@uppy/utils/lib/getTimeStamp.js\");\n/* eslint-disable no-console */\n\n\n// Swallow all logs, except errors.\n// default if logger is not set or debug: false\nconst justErrorsLogger = {\n  debug: () => {},\n  warn: () => {},\n  error: function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return console.error(`[Uppy] [${(0,_uppy_utils_lib_getTimeStamp__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()}]`, ...args);\n  }\n};\n\n// Print logs to console with namespace + timestamp,\n// set by logger: Uppy.debugLogger or debug: true\nconst debugLogger = {\n  debug: function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return console.debug(`[Uppy] [${(0,_uppy_utils_lib_getTimeStamp__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()}]`, ...args);\n  },\n  warn: function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return console.warn(`[Uppy] [${(0,_uppy_utils_lib_getTimeStamp__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()}]`, ...args);\n  },\n  error: function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return console.error(`[Uppy] [${(0,_uppy_utils_lib_getTimeStamp__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()}]`, ...args);\n  }\n};\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/core/lib/loggers.js?");

/***/ }),

/***/ "./node_modules/@uppy/core/lib/supportsUploadProgress.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uppy/core/lib/supportsUploadProgress.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ supportsUploadProgress)\n/* harmony export */ });\n// Edge 15.x does not fire 'progress' events on uploads.\n// See https://github.com/transloadit/uppy/issues/945\n// And https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12224510/\nfunction supportsUploadProgress(userAgent) {\n  // Allow passing in userAgent for tests\n  if (userAgent == null && typeof navigator !== 'undefined') {\n    // eslint-disable-next-line no-param-reassign\n    userAgent = navigator.userAgent;\n  }\n  // Assume it works because basically everything supports progress events.\n  if (!userAgent) return true;\n  const m = /Edge\\/(\\d+\\.\\d+)/.exec(userAgent);\n  if (!m) return true;\n  const edgeVersion = m[1];\n  const version = edgeVersion.split('.', 2);\n  const major = parseInt(version[0], 10);\n  const minor = parseInt(version[1], 10);\n\n  // Worked before:\n  // Edge 40.15063.0.0\n  // Microsoft EdgeHTML 15.15063\n  if (major < 15 || major === 15 && minor < 15063) {\n    return true;\n  }\n\n  // Fixed in:\n  // Microsoft EdgeHTML 18.18218\n  if (major > 18 || major === 18 && minor >= 18218) {\n    return true;\n  }\n\n  // other versions don't work.\n  return false;\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/core/lib/supportsUploadProgress.js?");

/***/ }),

/***/ "./node_modules/@uppy/store-default/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@uppy/store-default/lib/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _classPrivateFieldLooseBase(e, t) { if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\"); return e; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(e) { return \"__private_\" + id++ + \"_\" + e; }\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore We don't want TS to generate types for the package.json\nconst packageJson = {\n  \"version\": \"4.2.0\"\n};\nvar _callbacks = /*#__PURE__*/_classPrivateFieldLooseKey(\"callbacks\");\nvar _publish = /*#__PURE__*/_classPrivateFieldLooseKey(\"publish\");\n/**\n * Default store that keeps state in a simple object.\n */\nclass DefaultStore {\n  constructor() {\n    Object.defineProperty(this, _publish, {\n      value: _publish2\n    });\n    this.state = {};\n    Object.defineProperty(this, _callbacks, {\n      writable: true,\n      value: new Set()\n    });\n  }\n  getState() {\n    return this.state;\n  }\n  setState(patch) {\n    const prevState = {\n      ...this.state\n    };\n    const nextState = {\n      ...this.state,\n      ...patch\n    };\n    this.state = nextState;\n    _classPrivateFieldLooseBase(this, _publish)[_publish](prevState, nextState, patch);\n  }\n  subscribe(listener) {\n    _classPrivateFieldLooseBase(this, _callbacks)[_callbacks].add(listener);\n    return () => {\n      _classPrivateFieldLooseBase(this, _callbacks)[_callbacks].delete(listener);\n    };\n  }\n}\nfunction _publish2() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  _classPrivateFieldLooseBase(this, _callbacks)[_callbacks].forEach(listener => {\n    listener(...args);\n  });\n}\nDefaultStore.VERSION = packageJson.version;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DefaultStore);\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/store-default/lib/index.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/AbortController.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/AbortController.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortController: () => (/* binding */ AbortController),\n/* harmony export */   AbortSignal: () => (/* binding */ AbortSignal),\n/* harmony export */   createAbortError: () => (/* binding */ createAbortError)\n/* harmony export */ });\n/* harmony import */ var _hasProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hasProperty.js */ \"./node_modules/@uppy/utils/lib/hasProperty.js\");\n\n/**\n * Little AbortController proxy module so we can swap out the implementation easily later.\n */\nconst {\n  AbortController\n} = globalThis;\nconst {\n  AbortSignal\n} = globalThis;\nconst createAbortError = function (message, options) {\n  if (message === void 0) {\n    message = 'Aborted';\n  }\n  const err = new DOMException(message, 'AbortError');\n  if (options != null && (0,_hasProperty_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(options, 'cause')) {\n    Object.defineProperty(err, 'cause', {\n      // @ts-expect-error TS is drunk\n      __proto__: null,\n      configurable: true,\n      writable: true,\n      value: options.cause\n    });\n  }\n  return err;\n};\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/AbortController.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/ErrorWithCause.js":
/*!********************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/ErrorWithCause.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _hasProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hasProperty.js */ \"./node_modules/@uppy/utils/lib/hasProperty.js\");\n\nclass ErrorWithCause extends Error {\n  constructor(message, options) {\n    super(message);\n    this.cause = options == null ? void 0 : options.cause;\n    if (this.cause && (0,_hasProperty_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.cause, 'isNetworkError')) {\n      this.isNetworkError = this.cause.isNetworkError;\n    } else {\n      this.isNetworkError = false;\n    }\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ErrorWithCause);\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/ErrorWithCause.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/NetworkError.js":
/*!******************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/NetworkError.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass NetworkError extends Error {\n  constructor(error, xhr) {\n    if (xhr === void 0) {\n      xhr = null;\n    }\n    super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);\n    this.cause = error;\n    this.isNetworkError = true;\n    this.request = xhr;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NetworkError);\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/NetworkError.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/RateLimitedQueue.js":
/*!**********************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/RateLimitedQueue.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RateLimitedQueue: () => (/* binding */ RateLimitedQueue),\n/* harmony export */   internalRateLimitedQueue: () => (/* binding */ internalRateLimitedQueue)\n/* harmony export */ });\nfunction _classPrivateFieldLooseBase(e, t) { if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\"); return e; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(e) { return \"__private_\" + id++ + \"_\" + e; }\nfunction createCancelError(cause) {\n  return new Error('Cancelled', {\n    cause\n  });\n}\nfunction abortOn(signal) {\n  if (signal != null) {\n    var _this$then;\n    const abortPromise = () => this.abort(signal.reason);\n    signal.addEventListener('abort', abortPromise, {\n      once: true\n    });\n    const removeAbortListener = () => {\n      signal.removeEventListener('abort', abortPromise);\n    };\n    (_this$then = this.then) == null || _this$then.call(this, removeAbortListener, removeAbortListener);\n  }\n  return this;\n}\nvar _activeRequests = /*#__PURE__*/_classPrivateFieldLooseKey(\"activeRequests\");\nvar _queuedHandlers = /*#__PURE__*/_classPrivateFieldLooseKey(\"queuedHandlers\");\nvar _paused = /*#__PURE__*/_classPrivateFieldLooseKey(\"paused\");\nvar _pauseTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"pauseTimer\");\nvar _downLimit = /*#__PURE__*/_classPrivateFieldLooseKey(\"downLimit\");\nvar _upperLimit = /*#__PURE__*/_classPrivateFieldLooseKey(\"upperLimit\");\nvar _rateLimitingTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"rateLimitingTimer\");\nvar _call = /*#__PURE__*/_classPrivateFieldLooseKey(\"call\");\nvar _queueNext = /*#__PURE__*/_classPrivateFieldLooseKey(\"queueNext\");\nvar _next = /*#__PURE__*/_classPrivateFieldLooseKey(\"next\");\nvar _queue = /*#__PURE__*/_classPrivateFieldLooseKey(\"queue\");\nvar _dequeue = /*#__PURE__*/_classPrivateFieldLooseKey(\"dequeue\");\nvar _resume = /*#__PURE__*/_classPrivateFieldLooseKey(\"resume\");\nvar _increaseLimit = /*#__PURE__*/_classPrivateFieldLooseKey(\"increaseLimit\");\nclass RateLimitedQueue {\n  constructor(limit) {\n    Object.defineProperty(this, _dequeue, {\n      value: _dequeue2\n    });\n    Object.defineProperty(this, _queue, {\n      value: _queue2\n    });\n    Object.defineProperty(this, _next, {\n      value: _next2\n    });\n    Object.defineProperty(this, _queueNext, {\n      value: _queueNext2\n    });\n    Object.defineProperty(this, _call, {\n      value: _call2\n    });\n    Object.defineProperty(this, _activeRequests, {\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, _queuedHandlers, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _paused, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _pauseTimer, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _downLimit, {\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, _upperLimit, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _rateLimitingTimer, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _resume, {\n      writable: true,\n      value: () => this.resume()\n    });\n    Object.defineProperty(this, _increaseLimit, {\n      writable: true,\n      value: () => {\n        if (_classPrivateFieldLooseBase(this, _paused)[_paused]) {\n          _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], 0);\n          return;\n        }\n        _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] = this.limit;\n        this.limit = Math.ceil((_classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] + _classPrivateFieldLooseBase(this, _downLimit)[_downLimit]) / 2);\n        for (let i = _classPrivateFieldLooseBase(this, _downLimit)[_downLimit]; i <= this.limit; i++) {\n          _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();\n        }\n        if (_classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] - _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] > 3) {\n          _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], 2000);\n        } else {\n          _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] = Math.floor(_classPrivateFieldLooseBase(this, _downLimit)[_downLimit] / 2);\n        }\n      }\n    });\n    if (typeof limit !== 'number' || limit === 0) {\n      this.limit = Infinity;\n    } else {\n      this.limit = limit;\n    }\n  }\n  run(fn, queueOptions) {\n    if (!_classPrivateFieldLooseBase(this, _paused)[_paused] && _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] < this.limit) {\n      return _classPrivateFieldLooseBase(this, _call)[_call](fn);\n    }\n    return _classPrivateFieldLooseBase(this, _queue)[_queue](fn, queueOptions);\n  }\n  wrapSyncFunction(fn, queueOptions) {\n    var _this = this;\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const queuedRequest = _this.run(() => {\n        fn(...args);\n        queueMicrotask(() => queuedRequest.done());\n        return () => {};\n      }, queueOptions);\n      return {\n        abortOn,\n        abort() {\n          queuedRequest.abort();\n        }\n      };\n    };\n  }\n  wrapPromiseFunction(fn, queueOptions) {\n    var _this2 = this;\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      let queuedRequest;\n      const outerPromise = new Promise((resolve, reject) => {\n        queuedRequest = _this2.run(() => {\n          let cancelError;\n          let innerPromise;\n          try {\n            innerPromise = Promise.resolve(fn(...args));\n          } catch (err) {\n            innerPromise = Promise.reject(err);\n          }\n          innerPromise.then(result => {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              resolve(result);\n            }\n          }, err => {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              reject(err);\n            }\n          });\n          return cause => {\n            cancelError = createCancelError(cause);\n          };\n        }, queueOptions);\n      });\n      outerPromise.abort = cause => {\n        queuedRequest.abort(cause);\n      };\n      outerPromise.abortOn = abortOn;\n      return outerPromise;\n    };\n  }\n  resume() {\n    _classPrivateFieldLooseBase(this, _paused)[_paused] = false;\n    clearTimeout(_classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer]);\n    for (let i = 0; i < this.limit; i++) {\n      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();\n    }\n  }\n  /**\n   * Freezes the queue for a while or indefinitely.\n   *\n   * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.\n   *                                    If omitted, the queue won't resume automatically.\n   */\n  pause(duration) {\n    if (duration === void 0) {\n      duration = null;\n    }\n    _classPrivateFieldLooseBase(this, _paused)[_paused] = true;\n    clearTimeout(_classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer]);\n    if (duration != null) {\n      _classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer] = setTimeout(_classPrivateFieldLooseBase(this, _resume)[_resume], duration);\n    }\n  }\n\n  /**\n   * Pauses the queue for a duration, and lower the limit of concurrent requests\n   * when the queue resumes. When the queue resumes, it tries to progressively\n   * increase the limit in `this.#increaseLimit` until another call is made to\n   * `this.rateLimit`.\n   * Call this function when using the RateLimitedQueue for network requests and\n   * the remote server responds with 429 HTTP code.\n   *\n   * @param {number} duration in milliseconds.\n   */\n  rateLimit(duration) {\n    clearTimeout(_classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer]);\n    this.pause(duration);\n    if (this.limit > 1 && Number.isFinite(this.limit)) {\n      _classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] = this.limit - 1;\n      this.limit = _classPrivateFieldLooseBase(this, _downLimit)[_downLimit];\n      _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], duration);\n    }\n  }\n  get isPaused() {\n    return _classPrivateFieldLooseBase(this, _paused)[_paused];\n  }\n}\nfunction _call2(fn) {\n  _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] += 1;\n  let done = false;\n  let cancelActive;\n  try {\n    cancelActive = fn();\n  } catch (err) {\n    _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;\n    throw err;\n  }\n  return {\n    abort: cause => {\n      if (done) return;\n      done = true;\n      _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;\n      cancelActive == null || cancelActive(cause);\n      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();\n    },\n    done: () => {\n      if (done) return;\n      done = true;\n      _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;\n      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();\n    }\n  };\n}\nfunction _queueNext2() {\n  // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n  // one by one without continuously _advancing_ it (and starting new tasks before immediately\n  // aborting them)\n  queueMicrotask(() => _classPrivateFieldLooseBase(this, _next)[_next]());\n}\nfunction _next2() {\n  if (_classPrivateFieldLooseBase(this, _paused)[_paused] || _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] >= this.limit) {\n    return;\n  }\n  if (_classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].length === 0) {\n    return;\n  }\n\n  // Dispatch the next request, and update the abort/done handlers\n  // so that cancelling it does the Right Thing (and doesn't just try\n  // to dequeue an already-running request).\n  const next = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].shift();\n  if (next == null) {\n    throw new Error('Invariant violation: next is null');\n  }\n  const handler = _classPrivateFieldLooseBase(this, _call)[_call](next.fn);\n  next.abort = handler.abort;\n  next.done = handler.done;\n}\nfunction _queue2(fn, options) {\n  const handler = {\n    fn,\n    priority: (options == null ? void 0 : options.priority) || 0,\n    abort: () => {\n      _classPrivateFieldLooseBase(this, _dequeue)[_dequeue](handler);\n    },\n    done: () => {\n      throw new Error('Cannot mark a queued request as done: this indicates a bug');\n    }\n  };\n  const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].findIndex(other => {\n    return handler.priority > other.priority;\n  });\n  if (index === -1) {\n    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].push(handler);\n  } else {\n    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 0, handler);\n  }\n  return handler;\n}\nfunction _dequeue2(handler) {\n  const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].indexOf(handler);\n  if (index !== -1) {\n    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 1);\n  }\n}\nconst internalRateLimitedQueue = Symbol('__queue');\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/RateLimitedQueue.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/Translator.js":
/*!****************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/Translator.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Translator)\n/* harmony export */ });\nfunction _classPrivateFieldLooseBase(e, t) { if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\"); return e; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(e) { return \"__private_\" + id++ + \"_\" + e; }\n// We're using a generic because languages have different plural rules.\n\n// eslint-disable-next-line no-use-before-define\n\nfunction insertReplacement(source, rx, replacement) {\n  const newParts = [];\n  source.forEach(chunk => {\n    // When the source contains multiple placeholders for interpolation,\n    // we should ignore chunks that are not strings, because those\n    // can be JSX objects and will be otherwise incorrectly turned into strings.\n    // Without this condition we’d get this: [object Object] hello [object Object] my <button>\n    if (typeof chunk !== 'string') {\n      return newParts.push(chunk);\n    }\n    return rx[Symbol.split](chunk).forEach((raw, i, list) => {\n      if (raw !== '') {\n        newParts.push(raw);\n      }\n\n      // Interlace with the `replacement` value\n      if (i < list.length - 1) {\n        newParts.push(replacement);\n      }\n    });\n  });\n  return newParts;\n}\n\n/**\n * Takes a string with placeholder variables like `%{smart_count} file selected`\n * and replaces it with values from options `{smart_count: 5}`\n *\n * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE\n * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299\n *\n * @param phrase that needs interpolation, with placeholders\n * @param options with values that will be used to replace placeholders\n */\nfunction interpolate(phrase, options) {\n  const dollarRegex = /\\$/g;\n  const dollarBillsYall = '$$$$';\n  let interpolated = [phrase];\n  if (options == null) return interpolated;\n  for (const arg of Object.keys(options)) {\n    if (arg !== '_') {\n      // Ensure replacement value is escaped to prevent special $-prefixed\n      // regex replace tokens. the \"$$$$\" is needed because each \"$\" needs to\n      // be escaped with \"$\" itself, and we need two in the resulting output.\n      let replacement = options[arg];\n      if (typeof replacement === 'string') {\n        replacement = dollarRegex[Symbol.replace](replacement, dollarBillsYall);\n      }\n      // We create a new `RegExp` each time instead of using a more-efficient\n      // string replace so that the same argument can be replaced multiple times\n      // in the same phrase.\n      interpolated = insertReplacement(interpolated, new RegExp(`%\\\\{${arg}\\\\}`, 'g'), replacement);\n    }\n  }\n  return interpolated;\n}\nconst defaultOnMissingKey = key => {\n  throw new Error(`missing string: ${key}`);\n};\n\n/**\n * Translates strings with interpolation & pluralization support.\n * Extensible with custom dictionaries and pluralization functions.\n *\n * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,\n * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded\n * and can be easily added among with dictionaries, nested objects are used for pluralization\n * as opposed to `||||` delimeter\n *\n * Usage example: `translator.translate('files_chosen', {smart_count: 3})`\n */\nvar _onMissingKey = /*#__PURE__*/_classPrivateFieldLooseKey(\"onMissingKey\");\nvar _apply = /*#__PURE__*/_classPrivateFieldLooseKey(\"apply\");\nclass Translator {\n  constructor(locales, _temp) {\n    let {\n      onMissingKey = defaultOnMissingKey\n    } = _temp === void 0 ? {} : _temp;\n    Object.defineProperty(this, _apply, {\n      value: _apply2\n    });\n    Object.defineProperty(this, _onMissingKey, {\n      writable: true,\n      value: void 0\n    });\n    this.locale = {\n      strings: {},\n      pluralize(n) {\n        if (n === 1) {\n          return 0;\n        }\n        return 1;\n      }\n    };\n    if (Array.isArray(locales)) {\n      locales.forEach(_classPrivateFieldLooseBase(this, _apply)[_apply], this);\n    } else {\n      _classPrivateFieldLooseBase(this, _apply)[_apply](locales);\n    }\n    _classPrivateFieldLooseBase(this, _onMissingKey)[_onMissingKey] = onMissingKey;\n  }\n  /**\n   * Public translate method\n   *\n   * @param key\n   * @param options with values that will be used later to replace placeholders in string\n   * @returns string translated (and interpolated)\n   */\n  translate(key, options) {\n    return this.translateArray(key, options).join('');\n  }\n\n  /**\n   * Get a translation and return the translated and interpolated parts as an array.\n   *\n   * @returns The translated and interpolated parts, in order.\n   */\n  translateArray(key, options) {\n    let string = this.locale.strings[key];\n    if (string == null) {\n      _classPrivateFieldLooseBase(this, _onMissingKey)[_onMissingKey](key);\n      string = key;\n    }\n    const hasPluralForms = typeof string === 'object';\n    if (hasPluralForms) {\n      if (options && typeof options.smart_count !== 'undefined') {\n        const plural = this.locale.pluralize(options.smart_count);\n        return interpolate(string[plural], options);\n      }\n      throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}');\n    }\n    if (typeof string !== 'string') {\n      throw new Error(`string was not a string`);\n    }\n    return interpolate(string, options);\n  }\n}\nfunction _apply2(locale) {\n  if (!(locale != null && locale.strings)) {\n    return;\n  }\n  const prevLocale = this.locale;\n  Object.assign(this.locale, {\n    strings: {\n      ...prevLocale.strings,\n      ...locale.strings\n    },\n    pluralize: locale.pluralize || prevLocale.pluralize\n  });\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/Translator.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/UserFacingApiError.js":
/*!************************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/UserFacingApiError.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass UserFacingApiError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'UserFacingApiError';\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UserFacingApiError);\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/UserFacingApiError.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/fetchWithNetworkError.js":
/*!***************************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/fetchWithNetworkError.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fetchWithNetworkError)\n/* harmony export */ });\n/* harmony import */ var _NetworkError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NetworkError.js */ \"./node_modules/@uppy/utils/lib/NetworkError.js\");\n\n\n/**\n * Wrapper around window.fetch that throws a NetworkError when appropriate\n */\nfunction fetchWithNetworkError() {\n  return fetch(...arguments).catch(err => {\n    if (err.name === 'AbortError') {\n      throw err;\n    } else {\n      throw new _NetworkError_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](err);\n    }\n  });\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/fetchWithNetworkError.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/fileFilters.js":
/*!*****************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/fileFilters.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filterFilesToEmitUploadStarted: () => (/* binding */ filterFilesToEmitUploadStarted),\n/* harmony export */   filterNonFailedFiles: () => (/* binding */ filterNonFailedFiles)\n/* harmony export */ });\nfunction filterNonFailedFiles(files) {\n  const hasError = file => 'error' in file && !!file.error;\n  return files.filter(file => !hasError(file));\n}\n\n// Don't double-emit upload-started for Golden Retriever-restored files that were already started\nfunction filterFilesToEmitUploadStarted(files) {\n  return files.filter(file => {\n    var _file$progress;\n    return !((_file$progress = file.progress) != null && _file$progress.uploadStarted) || !file.isRestored;\n  });\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/fileFilters.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/generateFileID.js":
/*!********************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/generateFileID.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ generateFileID),\n/* harmony export */   getSafeFileId: () => (/* binding */ getSafeFileId)\n/* harmony export */ });\n/* harmony import */ var _getFileType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFileType.js */ \"./node_modules/@uppy/utils/lib/getFileType.js\");\n\nfunction encodeCharacter(character) {\n  return character.charCodeAt(0).toString(32);\n}\nfunction encodeFilename(name) {\n  let suffix = '';\n  return name.replace(/[^A-Z0-9]/gi, character => {\n    suffix += `-${encodeCharacter(character)}`;\n    return '/';\n  }) + suffix;\n}\n\n/**\n * Takes a file object and turns it into fileID, by converting file.name to lowercase,\n * removing extra characters and adding type, size and lastModified\n */\nfunction generateFileID(file, instanceId) {\n  // It's tempting to do `[items].filter(Boolean).join('-')` here, but that\n  // is slower! simple string concatenation is fast\n\n  let id = instanceId || 'uppy';\n  if (typeof file.name === 'string') {\n    id += `-${encodeFilename(file.name.toLowerCase())}`;\n  }\n  if (file.type !== undefined) {\n    id += `-${file.type}`;\n  }\n  if (file.meta && typeof file.meta.relativePath === 'string') {\n    id += `-${encodeFilename(file.meta.relativePath.toLowerCase())}`;\n  }\n  if (file.data.size !== undefined) {\n    id += `-${file.data.size}`;\n  }\n  if (file.data.lastModified !== undefined) {\n    id += `-${file.data.lastModified}`;\n  }\n  return id;\n}\n\n// If the provider has a stable, unique ID, then we can use that to identify the file.\n// Then we don't have to generate our own ID, and we can add the same file many times if needed (different path)\nfunction hasFileStableId(file) {\n  if (!file.isRemote || !file.remote) return false;\n  // These are the providers that it seems like have stable IDs for their files. The other's I haven't checked yet.\n  const stableIdProviders = new Set(['box', 'dropbox', 'drive', 'facebook', 'unsplash']);\n  return stableIdProviders.has(file.remote.provider);\n}\nfunction getSafeFileId(file, instanceId) {\n  if (hasFileStableId(file)) return file.id;\n  const fileType = (0,_getFileType_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(file);\n  return generateFileID({\n    ...file,\n    type: fileType\n  }, instanceId);\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/generateFileID.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/getAllowedMetaFields.js":
/*!**************************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/getAllowedMetaFields.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getAllowedMetaFields)\n/* harmony export */ });\nfunction getAllowedMetaFields(fields, meta) {\n  if (fields === true) {\n    return Object.keys(meta);\n  }\n  if (Array.isArray(fields)) {\n    return fields;\n  }\n  return [];\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/getAllowedMetaFields.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/getFileNameAndExtension.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/getFileNameAndExtension.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getFileNameAndExtension)\n/* harmony export */ });\n/**\n * Takes a full filename string and returns an object {name, extension}\n */\nfunction getFileNameAndExtension(fullFileName) {\n  const lastDot = fullFileName.lastIndexOf('.');\n  // these count as no extension: \"no-dot\", \"trailing-dot.\"\n  if (lastDot === -1 || lastDot === fullFileName.length - 1) {\n    return {\n      name: fullFileName,\n      extension: undefined\n    };\n  }\n  return {\n    name: fullFileName.slice(0, lastDot),\n    extension: fullFileName.slice(lastDot + 1)\n  };\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/getFileNameAndExtension.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/getFileType.js":
/*!*****************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/getFileType.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getFileType)\n/* harmony export */ });\n/* harmony import */ var _getFileNameAndExtension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFileNameAndExtension.js */ \"./node_modules/@uppy/utils/lib/getFileNameAndExtension.js\");\n/* harmony import */ var _mimeTypes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mimeTypes.js */ \"./node_modules/@uppy/utils/lib/mimeTypes.js\");\n\n\nfunction getFileType(file) {\n  var _getFileNameAndExtens;\n  if (file.type) return file.type;\n  const fileExtension = file.name ? (_getFileNameAndExtens = (0,_getFileNameAndExtension_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(file.name).extension) == null ? void 0 : _getFileNameAndExtens.toLowerCase() : null;\n  if (fileExtension && fileExtension in _mimeTypes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n    // else, see if we can map extension to a mime type\n    return _mimeTypes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"][fileExtension];\n  }\n  // if all fails, fall back to a generic byte stream type\n  return 'application/octet-stream';\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/getFileType.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/getSocketHost.js":
/*!*******************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/getSocketHost.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getSocketHost)\n/* harmony export */ });\nfunction getSocketHost(url) {\n  var _regex$exec;\n  // get the host domain\n  const regex = /^(?:https?:\\/\\/|\\/\\/)?(?:[^@\\n]+@)?(?:www\\.)?([^\\n]+)/i;\n  const host = (_regex$exec = regex.exec(url)) == null ? void 0 : _regex$exec[1];\n  const socketProtocol = /^http:\\/\\//i.test(url) ? 'ws' : 'wss';\n  return `${socketProtocol}://${host}`;\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/getSocketHost.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/getTimeStamp.js":
/*!******************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/getTimeStamp.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getTimeStamp)\n/* harmony export */ });\n/**\n * Adds zero to strings shorter than two characters.\n */\nfunction pad(number) {\n  return number < 10 ? `0${number}` : number.toString();\n}\n\n/**\n * Returns a timestamp in the format of `hours:minutes:seconds`\n */\nfunction getTimeStamp() {\n  const date = new Date();\n  const hours = pad(date.getHours());\n  const minutes = pad(date.getMinutes());\n  const seconds = pad(date.getSeconds());\n  return `${hours}:${minutes}:${seconds}`;\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/getTimeStamp.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/hasProperty.js":
/*!*****************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/hasProperty.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ has)\n/* harmony export */ });\nfunction has(object, key) {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/hasProperty.js?");

/***/ }),

/***/ "./node_modules/@uppy/utils/lib/mimeTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/@uppy/utils/lib/mimeTypes.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// ___Why not add the mime-types package?\n//    It's 19.7kB gzipped, and we only need mime types for well-known extensions (for file previews).\n// ___Where to take new extensions from?\n//    https://github.com/jshttp/mime-db/blob/master/db.json\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  __proto__: null,\n  md: 'text/markdown',\n  markdown: 'text/markdown',\n  mp4: 'video/mp4',\n  mp3: 'audio/mp3',\n  svg: 'image/svg+xml',\n  jpg: 'image/jpeg',\n  png: 'image/png',\n  webp: 'image/webp',\n  gif: 'image/gif',\n  heic: 'image/heic',\n  heif: 'image/heif',\n  yaml: 'text/yaml',\n  yml: 'text/yaml',\n  csv: 'text/csv',\n  tsv: 'text/tab-separated-values',\n  tab: 'text/tab-separated-values',\n  avi: 'video/x-msvideo',\n  mks: 'video/x-matroska',\n  mkv: 'video/x-matroska',\n  mov: 'video/quicktime',\n  dicom: 'application/dicom',\n  doc: 'application/msword',\n  docm: 'application/vnd.ms-word.document.macroenabled.12',\n  docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  dot: 'application/msword',\n  dotm: 'application/vnd.ms-word.template.macroenabled.12',\n  dotx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n  xla: 'application/vnd.ms-excel',\n  xlam: 'application/vnd.ms-excel.addin.macroenabled.12',\n  xlc: 'application/vnd.ms-excel',\n  xlf: 'application/x-xliff+xml',\n  xlm: 'application/vnd.ms-excel',\n  xls: 'application/vnd.ms-excel',\n  xlsb: 'application/vnd.ms-excel.sheet.binary.macroenabled.12',\n  xlsm: 'application/vnd.ms-excel.sheet.macroenabled.12',\n  xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n  xlt: 'application/vnd.ms-excel',\n  xltm: 'application/vnd.ms-excel.template.macroenabled.12',\n  xltx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n  xlw: 'application/vnd.ms-excel',\n  txt: 'text/plain',\n  text: 'text/plain',\n  conf: 'text/plain',\n  log: 'text/plain',\n  pdf: 'application/pdf',\n  zip: 'application/zip',\n  '7z': 'application/x-7z-compressed',\n  rar: 'application/x-rar-compressed',\n  tar: 'application/x-tar',\n  gz: 'application/gzip',\n  dmg: 'application/x-apple-diskimage'\n});\n\n//# sourceURL=webpack://vpuploader/./node_modules/@uppy/utils/lib/mimeTypes.js?");

/***/ }),

/***/ "./node_modules/is-network-error/index.js":
/*!************************************************!*\
  !*** ./node_modules/is-network-error/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isNetworkError)\n/* harmony export */ });\nconst objectToString = Object.prototype.toString;\n\nconst isError = value => objectToString.call(value) === '[object Error]';\n\nconst errorMessages = new Set([\n\t'network error', // Chrome\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari 16\n\t'Load failed', // Safari 17+\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n\t'terminated', // Undici (Node.js)\n]);\n\nfunction isNetworkError(error) {\n\tconst isValid = error\n\t\t&& isError(error)\n\t\t&& error.name === 'TypeError'\n\t\t&& typeof error.message === 'string';\n\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\t// We do an extra check for Safari 17+ as it has a very generic error message.\n\t// Network errors in Safari have no stack.\n\tif (error.message === 'Load failed') {\n\t\treturn error.stack === undefined;\n\t}\n\n\treturn errorMessages.has(error.message);\n}\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/is-network-error/index.js?");

/***/ }),

/***/ "./node_modules/nanoid/non-secure/index.js":
/*!*************************************************!*\
  !*** ./node_modules/nanoid/non-secure/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/nanoid/non-secure/index.js?");

/***/ }),

/***/ "./node_modules/p-retry/index.js":
/*!***************************************!*\
  !*** ./node_modules/p-retry/index.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   \"default\": () => (/* binding */ pRetry)\n/* harmony export */ });\n/* harmony import */ var retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! retry */ \"./node_modules/retry/index.js\");\n/* harmony import */ var is_network_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-network-error */ \"./node_modules/is-network-error/index.js\");\n\n\n\nclass AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nasync function pRetry(input, options) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = {...options};\n\t\toptions.onFailedAttempt ??= () => {};\n\t\toptions.shouldRetry ??= () => true;\n\t\toptions.retries ??= 10;\n\n\t\tconst operation = retry__WEBPACK_IMPORTED_MODULE_0__.operation(options);\n\n\t\tconst abortHandler = () => {\n\t\t\toperation.stop();\n\t\t\treject(options.signal?.reason);\n\t\t};\n\n\t\tif (options.signal && !options.signal.aborted) {\n\t\t\toptions.signal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tconst cleanUp = () => {\n\t\t\toptions.signal?.removeEventListener('abort', abortHandler);\n\t\t\toperation.stop();\n\t\t};\n\n\t\toperation.attempt(async attemptNumber => {\n\t\t\ttry {\n\t\t\t\tconst result = await input(attemptNumber);\n\t\t\t\tcleanUp();\n\t\t\t\tresolve(result);\n\t\t\t} catch (error) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\t\tthrow new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof AbortError) {\n\t\t\t\t\t\tthrow error.originalError;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof TypeError && !(0,is_network_error__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(error)) {\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\t\tif (!(await options.shouldRetry(error))) {\n\t\t\t\t\t\toperation.stop();\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait options.onFailedAttempt(error);\n\n\t\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\t\tthrow operation.mainError();\n\t\t\t\t\t}\n\t\t\t\t} catch (finalError) {\n\t\t\t\t\tdecorateErrorWithCounts(finalError, attemptNumber, options);\n\t\t\t\t\tcleanUp();\n\t\t\t\t\treject(finalError);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n\n//# sourceURL=webpack://vpuploader/./node_modules/p-retry/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _uppy_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @uppy/core */ \"./node_modules/@uppy/core/lib/Uppy.js\");\n/* harmony import */ var _uppy_aws_s3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uppy/aws-s3 */ \"./node_modules/@uppy/aws-s3/lib/index.js\");\n\n\n\nconst DEFAULT_CONFIG = {\n\tchunkSize: 50 * 1024 * 1024, // 50 MiB\n\tdebug: true,\n\tallowedFileTypes: [\"video/*\"],\n};\n\nclass VpUploader {\n\t/**\n\t * Constructor to initialize VpUploader\n\t * @param {Object} config - Configuration options\n\t * @param {number} config.chunkSize - Chunk size for multipart uploads in bytes.\n\t * @param {boolean} config.debug - Enable debug mode for Uppy\n\t */\n\tconstructor(config) {\n\t\tthis.config = this.validateConfig(config);\n\t\tthis.chunkSize = this.config.chunkSize;\n\t\tthis.debug = this.config.debug;\n\t\tthis.allowedFileTypes = this.config.allowedFileTypes;\n\t\tthis.presignedUrls = [];\n\t\tthis.uploadId = null;\n\t\tthis.requestKey = null;\n\t\tthis.uppy = null;\n\t\tthis.isMultiPart = false;\n\t\t/**\n\t\t * Callback to be called on multipart complete.\n\t\t * Gets called with an object containing requestKey and parts.\n\t\t * @param {Object} details - Object containing requestKey and parts\n\t\t * @param {string} details.requestKey - Request key for the upload\n\t\t * @param {Array} details.parts - Array of parts containing partNumber and eTag\n\t\t */\n\t\tthis.onMultipartComplete = null;\n\t\t/**\n\t\t * Callback to be called on upload progress.\n\t\t * @param {Number} progress - Progress amount\n\t\t */\n\t\tthis.onProgress = null;\n\t\t/**\n\t\t * Callback to be called on successful upload.\n\t\t * Gets called with an object containing requestKey.\n\t\t * @param {Object} details - Object containing requestKey\n\t\t * @param {string} details.requestKey - Request key for the upload\n\t\t */\n\t\tthis.onSuccess = null;\n\t\t/**\n\t\t * Callback to be called on upload error.\n\t\t * @param {Error} error - Error object\n\t\t */\n\t\tthis.onError = null;\n\n\t\tthis.initializeUppy();\n\t}\n\n\tinitializeUppy() {\n\t\tthis.uppy = new _uppy_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n\t\t\tdebug: this.debug,\n\t\t\trestrictions: {\n\t\t\t\tallowedFileTypes: this.allowedFileTypes,\n\t\t\t},\n\t\t\tautoProceed: false,\n\t\t});\n\n\t\tthis.uppy.use(_uppy_aws_s3__WEBPACK_IMPORTED_MODULE_0__[\"default\"], {\n\t\t\tgetChunkSize: () => this.chunkSize,\n\t\t\tshouldUseMultipart: () => true,\n\t\t\tcreateMultipartUpload: this.handleCreateMultipartUpload.bind(this),\n\t\t\tsignPart: this.handleSignPart.bind(this),\n\t\t\tcompleteMultipartUpload: this.handleCompleteMultipartUpload.bind(this),\n\t\t});\n\n\t\tthis.setUppyEventListeners();\n\t\tthis.bindGetterMethods();\n\t}\n\n\tasync handleCreateMultipartUpload(file) {\n\t\ttry {\n\t\t\tif (!this.requestKey) throw new Error(\"Request key not set.\");\n\t\t\tif (this.isMultiPart && !this.uploadId)\n\t\t\t\tthrow new Error(\"Upload ID not set. This is needed for multipart uploads.\");\n\n\t\t\treturn { uploadId: this.uploadId, key: this.requestKey };\n\t\t} catch (error) {\n\t\t\tthis.log(`Error in createMultipartUpload: ${error}`, \"error\");\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\thandleSignPart(file, partData) {\n\t\ttry {\n\t\t\tif (!this.presignedUrls) throw new Error(\"Presigned URLs are missing\");\n\n\t\t\tconst index = this.isMultiPart ? partData.partNumber - 1 : 0;\n\t\t\tconst url = this.presignedUrls[index];\n\t\t\treturn { url, headers: { \"Content-Type\": \"application/octet-stream\" } };\n\t\t} catch (error) {\n\t\t\tthis.log(`Error in signPart: ${error}`, \"error\");\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t// This method needs to return an object to fit with the Uppy API, but we don't need to do anything here so we just return an empty object.\n\tasync handleCompleteMultipartUpload(file, { uploadId, key, parts }) {\n\t\ttry {\n\t\t\t// Skip in case of single part upload\n\t\t\tif (!this.isMultiPart) return {};\n\n\t\t\tif (!this.onMultipartComplete) {\n\t\t\t\tthis.log(\"No onMultipartComplete callback provided\", \"warn\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst parsedParts = parts.map((part) => ({\n\t\t\t\teTag: part.ETag.split('\"').join(\"\"),\n\t\t\t\tpartNumber: part.PartNumber,\n\t\t\t}));\n\n\t\t\tthis.onMultipartComplete({\n\t\t\t\trequestKey: key,\n\t\t\t\tparts: parsedParts,\n\t\t\t});\n\n\t\t\treturn {};\n\t\t} catch (error) {\n\t\t\tthis.log(`Error in completeMultipartUpload: ${error}`, \"error\");\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tsetUppyEventListeners() {\n\t\tthis.uppy.on(\"progress\", (progress) => {\n\t\t\tif (!this.onProgress) return;\n\t\t\tthis.onProgress(progress);\n\t\t});\n\n\t\tthis.uppy.on(\"upload-success\", async (file) => {\n\t\t\tthis.log(\"Upload successful\", \"info\");\n\t\t\tif (!this.onSuccess) {\n\t\t\t\tthis.log(\"No onSuccess callback provided\", \"warn\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst requestKey = file.s3Multipart.key;\n\t\t\tthis.onSuccess({ requestKey });\n\n\t\t\t// Clear the state after successful upload\n\t\t\t// Shouldnt be called if upload is ongoing\n\t\t\t// this.uppy.clear();\n\t\t});\n\n\t\tthis.uppy.on(\"error\", async (error) => {\n\t\t\tthis.log(`Upload error: ${error}`, \"error\");\n\n\t\t\tif (!this.onError) {\n\t\t\t\tthis.log(\"No onError callback provided\", \"warn\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.onError(error);\n\t\t});\n\t}\n\n\tbindGetterMethods() {\n\t\tthis.getFile = this.uppy.getFile.bind(this.uppy);\n\t\tthis.getFiles = this.uppy.getFiles.bind(this.uppy);\n\t\tthis.getFilesByIds = this.uppy.getFilesByIds.bind(this.uppy);\n\t\tthis.getState = this.uppy.getState.bind(this.uppy);\n\t\tthis.getObjectOfFilesPerState = this.uppy.getObjectOfFilesPerState.bind(this.uppy);\n\t}\n\n\tvalidateConfig(userConfig = {}) {\n\t\ttry {\n\t\t\tif (typeof userConfig !== \"object\" || userConfig === null) {\n\t\t\t\tthrow new Error(\"Configuration must be an object.\");\n\t\t\t}\n\n\t\t\t// Create a new configuration object by merging defaults and userConfig\n\t\t\tconst finalConfig = { ...DEFAULT_CONFIG, ...userConfig };\n\n\t\t\t// Validate each configuration option\n\t\t\tObject.keys(finalConfig).forEach((key) => {\n\t\t\t\tswitch (key) {\n\t\t\t\t\tcase \"chunkSize\":\n\t\t\t\t\t\tif (typeof finalConfig.chunkSize !== \"number\" || finalConfig.chunkSize <= 0) {\n\t\t\t\t\t\t\tthrow new Error(\"'chunkSize' must be a positive number.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"debug\":\n\t\t\t\t\t\tif (typeof finalConfig.debug !== \"boolean\") {\n\t\t\t\t\t\t\tthrow new Error(\"'debug' must be a boolean.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"allowedFileTypes\":\n\t\t\t\t\t\tif (!Array.isArray(finalConfig.allowedFileTypes)) {\n\t\t\t\t\t\t\tthrow new Error(\"'allowedFileTypes' must be an array.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn(`Unknown configuration option: ${key}`);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Return the validated and merged configuration\n\t\t\treturn finalConfig;\n\t\t} catch (error) {\n\t\t\tthis.log(`Error in validateConfig: ${error}`, \"error\");\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tvalidateDetails(details) {\n\t\ttry {\n\t\t\tif (typeof details !== \"object\" || details === null) {\n\t\t\t\tthrow new Error(\"Details must be an object.\");\n\t\t\t}\n\n\t\t\tif (typeof details.requestKey !== \"string\" || details.requestKey.length === 0) {\n\t\t\t\tthrow new Error(\"Request key must be a non-empty string.\");\n\t\t\t}\n\n\t\t\tif (!Array.isArray(details.presignedUrls) || details.presignedUrls.length === 0) {\n\t\t\t\tthrow new Error(\"Presigned URLs must be a non-empty array.\");\n\t\t\t}\n\n\t\t\tif (this.isMultiPart) {\n\t\t\t\tif (typeof details.uploadId !== \"string\" || details.uploadId.length === 0) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"Upload ID is required for multipart uploads and must be a non-empty string.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (details.presignedUrls.length === 1) {\n\t\t\t\t\tthrow new Error(\"Presigned URLs must be an array of URLs for each part.\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.log(`Error in validateDetails: ${error}`, \"error\");\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {Object} callbacks - Callbacks to be used by the uploader\n\t * @param {Function} callbacks.onMultipartComplete - Callback to be called on multipart complete\n\t * @param {Function} callbacks.onSuccess - Callback to be called on successful\n\t * @param {Function} callbacks.onError - Callback to be called on error\n\t * @param {Function} callbacks.onProgress - Callback to be called on progress\n\t */\n\tuse(callbacks) {\n\t\tif (callbacks.onMultipartComplete) this.onMultipartComplete = callbacks.onMultipartComplete;\n\t\tif (callbacks.onSuccess) this.onSuccess = callbacks.onSuccess;\n\t\tif (callbacks.onError) this.onError = callbacks.onError;\n\t\tif (callbacks.onProgress) this.onProgress = callbacks.onProgress;\n\t}\n\n\t/**\n\t *\n\t * @param {*} file - File to be uploaded\n\t * @param {*} details.requestKey - Request key for the upload\n\t * @param {*} details.uploadId - Upload ID for the upload\n\t * @param {*} details.presignedUrls - Array of presigned URLs for each part\n\t * @param {*} onMultipartComplete - Callback to be called on multipart complete\n\t * @param {*} onSuccess - Callback to be called on successful\n\t */\n\tupload(file, details) {\n\t\tif (!(file instanceof File)) {\n\t\t\tthrow new Error(\"Invalid file provided. Please provide a File object.\");\n\t\t}\n\n\t\tthis.isMultiPart = file.size > this.chunkSize;\n\n\t\tthis.validateDetails(details);\n\n\t\tthis.requestKey = details.requestKey;\n\t\tthis.uploadId = details.uploadId;\n\t\tthis.presignedUrls = details.presignedUrls;\n\n\t\tthis.uppy.addFile({\n\t\t\tname: file.name,\n\t\t\ttype: file.type,\n\t\t\tdata: file,\n\t\t});\n\n\t\tthis.uppy.upload();\n\t}\n\n\tlog(message, level = \"log\") {\n\t\tif (this.debug) console[level](message);\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VpUploader);\n\n\n//# sourceURL=webpack://vpuploader/./src/index.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__webpack_require__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ var __webpack_exports__default = __webpack_exports__["default"];
/******/ export { __webpack_exports__default as default };
/******/ 
